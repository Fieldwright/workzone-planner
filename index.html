<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Work Zone Planner Pro - Enhanced Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
<style>
  :root { --bg:#0b1020; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb; --accent:#60a5fa; --success:#22c55e; --warn:#f59e0b; --danger:#ef4444; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:13px/1.25 system-ui,Segoe UI,Arial}
  #app{display:grid;grid-template-columns:380px 1fr;min-height:100vh}
  aside{background:var(--panel);padding:10px 12px;border-right:1px solid #1f2937;overflow-y:auto;overflow-x:hidden;max-height:100vh}
  h1{font-size:16px;margin:0 0 4px;display:flex;align-items:center;gap:6px}
  .badge{display:inline-block;background:var(--accent);color:#000;padding:1px 5px;border-radius:4px;font-size:9px;font-weight:bold}
  .sub{color:var(--muted);font-size:11px;margin-bottom:8px;line-height:1.4}
  
  /* Collapsible sections */
  .section{margin:10px 0;border:1px solid #1f2937;border-radius:8px;overflow:hidden}
  .section-header{background:#1a2332;padding:8px 10px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;user-select:none}
  .section-header:hover{background:#1f2937}
  .section-title{font-weight:600;font-size:13px;display:flex;align-items:center;gap:6px}
  .section-icon{font-size:10px;transition:transform 0.2s}
  .section-icon.collapsed{transform:rotate(-90deg)}
  .section-content{padding:10px;display:block}
  .section-content.collapsed{display:none}
  
  label{display:block;margin:4px 0 2px;color:#cbd5e1;font-size:12px;display:flex;align-items:center;gap:4px}
  .tooltip{color:var(--muted);cursor:help;font-size:10px}
  input[type="number"],input[type="text"]{width:100%;padding:6px 8px;border-radius:8px;border:1px solid #253041;background:#0b1220;color:#e5e7eb;font-size:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-bottom:6px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:6px}
  .btns{display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:6px}
  .btns3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-top:6px}
  button{cursor:pointer;padding:8px;border:0;border-radius:10px;background:var(--accent);color:#03122a;font-weight:600;font-size:12px;transition:opacity 0.2s}
  button:hover{opacity:0.9}
  button.secondary{background:#374151;color:#e5e7eb}
  button.warn{background:var(--warn);color:#000}
  button.danger{background:var(--danger);color:#fff}
  button:disabled{opacity:0.5;cursor:not-allowed}
  .stat{margin-top:4px;font-size:12px;color:#cbd5e1;padding:4px 6px;background:#0b1220;border-radius:6px}
  .stat strong{color:var(--accent)}
  .hr{border-top:1px solid #1f2937;margin:8px 0}
  #map{height:100vh;width:100%}
  
  /* Leaflet Layer Control Styling */
  .leaflet-control-layers{background:var(--panel);border:2px solid var(--accent);border-radius:8px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.5)}
  .leaflet-control-layers-toggle{background-image:url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjZTVlN2ViIiBkPSJNIDYgOCBMIDMwIDggTCAzMCAxMCBMIDYgMTAgWiBNIDYgMTcgTCAzMCAxNyBMIDMwIDE5IEwgNiAxOSBaIE0gNiAyNiBMIDMwIDI2IEwgMzAgMjggTCA2IDI4IFoiLz48L3N2Zz4=');background-size:26px 26px;width:36px;height:36px}
  .leaflet-control-layers-list{color:var(--text);font-size:13px}
  .leaflet-control-layers-base label{display:flex;align-items:center;gap:6px;padding:4px;cursor:pointer;transition:background 0.2s}
  .leaflet-control-layers-base label:hover{background:rgba(96,165,250,0.1);border-radius:4px}
  .leaflet-control-layers-separator{border-top:1px solid #374151;margin:4px 0}
  .leaflet-control-layers input{cursor:pointer}
  
  /* Enhanced Zoom Controls */
  .leaflet-control-zoom{border:2px solid var(--accent);border-radius:8px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.5)}
  .leaflet-control-zoom a{background:var(--panel);color:var(--text);border-bottom:1px solid #374151;width:36px;height:36px;line-height:36px;font-size:20px;font-weight:bold}
  .leaflet-control-zoom a:hover{background:#1f2937}
  .leaflet-control-zoom a:last-child{border-bottom:none}
  .leaflet-bar{box-shadow:none}
  
  /* Scale Control */
  .leaflet-control-scale{background:rgba(17,24,39,0.9);border:2px solid var(--accent);border-radius:6px;padding:2px 8px;font-size:11px;font-weight:bold;color:var(--text);box-shadow:0 2px 8px rgba(0,0,0,0.5)}
  .leaflet-control-scale-line{border:2px solid var(--accent);border-top:none;color:var(--text);background:transparent}
  
  /* Icons */
  .cone {width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:20px solid #ff6a00;position:relative;transform:translate(-8px,-20px);filter:drop-shadow(0 1px 0 #7a2d00);}
  .cone:after {content:"";position:absolute;left:-10px;bottom:-5px;width:20px;height:5px;background:#7a2d00;border-radius:3px;}
  .station-label {background:#1e293b;color:white;padding:1px 4px;border-radius:3px;font-size:10px;font-weight:bold;white-space:nowrap;border:1px solid #475569}
  .sign-pill {display:inline-flex;align-items:center;gap:6px;padding:4px 6px;border-radius:8px;background:#facc15;color:#111827;border:2px solid #000;box-shadow:0 1px 0 rgba(0,0,0,.6);font-weight:700;user-select:none;cursor:grab;font-size:10px;line-height:1.1}
  .sign-palette {display:grid;grid-template-columns:1fr 1fr;gap:6px;max-height:300px;overflow-y:auto;padding:4px}
  .radio-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;font-size:12px;margin:4px 0}
  .radio-row label{display:flex;gap:4px;align-items:center;color:#e5e7eb;margin:0}
  .topline{display:flex;align-items:center;justify-content:space-between;gap:6px;margin-bottom:8px}
  .topline .inline-btns{display:flex;gap:6px}
  .chk-row{display:flex;gap:6px;align-items:center;color:#e5e7eb;font-size:12px;margin:4px 0}
  .handle{background:#111827;border:1px solid #475569;color:#e5e7eb;border-radius:6px;padding:2px 6px;font-size:10px;margin-top:4px}
  .rot-toolbar{background:#111827;border:1px solid #475569;color:#e5e7eb;border-radius:6px;padding:2px 4px;font-size:11px;display:flex;gap:6px;align-items:center}
  .rot-btn{background:#374151;color:#e5e7eb;border-radius:4px;border:1px solid #64748b;padding:1px 4px;cursor:pointer}

  /* Arrow board animation */
  @keyframes arrow-blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }
  .arrow-board{background:#000;border:3px solid #f59e0b;padding:4px;border-radius:4px;display:flex;gap:2px}
  .arrow-segment{width:6px;height:20px;background:#f59e0b;animation:arrow-blink 0.5s infinite}
  .arrow-segment:nth-child(2){animation-delay:0.15s}
  .arrow-segment:nth-child(3){animation-delay:0.3s}

  /* Compliance badges */
  .taper-badge {background:var(--success);color:white;padding:2px 6px;border-radius:4px;font-size:11px;font-weight:bold;white-space:nowrap;}
  .taper-badge.short {background:var(--danger);}
  .taper-badge.warning {background:var(--warn);color:#000}
  .leaflet-popup-content-wrapper.dark-popup {background:#111827;color:#e5e7eb;border:1px solid #475569;border-radius:8px;}
  .leaflet-popup-tip.dark-popup {background:#111827;}

  /* Measurement tool */
  .measure-line{stroke:#22c55e;stroke-width:3;stroke-dasharray:5,5}
  .measure-label{background:var(--success);color:#000;padding:2px 6px;border-radius:4px;font-size:11px;font-weight:bold}

  /* Mobile responsive */
  @media (max-width: 768px) {
    #app{grid-template-columns:1fr;position:relative}
    aside{position:absolute;top:0;left:0;width:100%;max-width:350px;z-index:1000;max-height:80vh;box-shadow:2px 0 10px rgba(0,0,0,0.5)}
    aside.mobile-hidden{transform:translateX(-100%);transition:transform 0.3s}
    .mobile-toggle{display:block !important;position:absolute;top:10px;left:10px;z-index:1001;background:var(--panel);border:1px solid #475569;padding:8px 12px;border-radius:8px;cursor:pointer}
    #map{height:100vh}
  }
  .mobile-toggle{display:none}

  /* Print styles */
  .print-panel{display:none}
  @media print{
    body{background:white;color:black}
    #app{grid-template-columns:1fr}
    aside,.mobile-toggle{display:none}
    #map{height:7in;page-break-after:always}
    .print-panel{display:block;padding:12px;page-break-before:always}
    .print-panel h2{margin:8px 0 6px;font-size:18px;border-bottom:2px solid #000;padding-bottom:4px}
    .print-panel h3{margin:10px 0 4px;font-size:14px}
    .print-panel .cols{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .print-panel table{width:100%;border-collapse:collapse;margin:8px 0;font-size:12px}
    .print-panel th{background:#e5e7eb;padding:4px 8px;text-align:left;border:1px solid #000}
    .print-panel td{padding:4px 8px;border:1px solid #000}
    .qr-section{margin-top:16px;padding:12px;border:2px solid #000;text-align:center;background:white}
    .qr-section h3{margin-top:0}
    .qr-section canvas{border:20px solid white !important;background:white;display:block !important;margin:10px auto !important}
    .qr-section #qrcode{min-height:280px}
  }

  /* Field View (Mobile) */
  #fieldView{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:var(--bg);z-index:10000}
  #fieldView.active{display:flex;flex-direction:column}
  #fieldViewMap{flex:1;width:100%;position:relative}
  .field-header{background:var(--panel);padding:12px;border-bottom:2px solid var(--accent);box-shadow:0 2px 8px rgba(0,0,0,0.3)}
  .field-header h2{margin:0 0 4px;font-size:18px;color:var(--accent)}
  .field-header .info{font-size:12px;color:var(--muted)}
  
  /* Filter Buttons */
  .filter-bar{display:flex;gap:6px;padding:10px;background:var(--panel);border-bottom:1px solid #374151;overflow-x:auto;flex-wrap:wrap}
  .filter-btn{padding:6px 12px;border-radius:8px;border:2px solid #374151;background:#1f2937;color:var(--text);font-size:12px;font-weight:600;cursor:pointer;white-space:nowrap;transition:all 0.2s}
  .filter-btn:hover{background:#374151}
  .filter-btn.active{background:var(--accent);color:#000;border-color:var(--accent)}
  .filter-btn.taper{border-color:#22c55e}
  .filter-btn.taper.active{background:#22c55e}
  .filter-btn.buffer{border-color:#f59e0b}
  .filter-btn.buffer.active{background:#f59e0b}
  .filter-btn.sign{border-color:#facc15}
  .filter-btn.sign.active{background:#facc15}
  
  /* Navigation Panel */
  .nav-panel{position:absolute;top:10px;left:10px;right:10px;background:rgba(17,24,39,0.95);border-radius:12px;padding:12px;z-index:1000;border:2px solid var(--accent);box-shadow:0 4px 12px rgba(0,0,0,0.5);backdrop-filter:blur(10px)}
  .nav-panel.hidden{display:none}
  .nav-distance{font-size:32px;font-weight:bold;color:var(--accent);line-height:1;margin-bottom:4px}
  .nav-direction{font-size:14px;color:var(--text);margin-bottom:8px;display:flex;align-items:center;gap:8px}
  .nav-device{font-size:13px;color:var(--muted);border-top:1px solid #374151;padding-top:8px;margin-top:8px}
  .nav-device strong{color:var(--text)}
  
  /* Compass Arrow */
  .compass-container{position:absolute;top:120px;left:50%;transform:translateX(-50%);z-index:1000;pointer-events:none}
  .compass-arrow{width:60px;height:60px;background:rgba(34,197,94,0.95);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:32px;box-shadow:0 4px 12px rgba(0,0,0,0.5);border:3px solid #fff;transition:transform 0.3s ease}
  .compass-accuracy{background:rgba(17,24,39,0.9);color:var(--muted);padding:2px 8px;border-radius:4px;font-size:10px;text-align:center;margin-top:4px}
  
  /* Guidance Path */
  .guidance-line{stroke:#22c55e;stroke-width:3;stroke-dasharray:8,8;stroke-linecap:round;opacity:0.8;animation:dashMove 1s linear infinite}
  @keyframes dashMove{to{stroke-dashoffset:-16}}
  
  .field-controls{background:var(--panel);padding:10px;border-top:1px solid #1f2937;display:flex;gap:8px;flex-wrap:wrap}
  .field-controls button{flex:1;min-width:120px}
  .field-legend{display:flex;gap:12px;justify-content:center;padding:6px;font-size:11px;color:var(--muted);flex-basis:100%;border-top:1px solid #374151;margin-top:4px;padding-top:8px}
  .field-legend-item{display:flex;align-items:center;gap:4px}
  .field-legend-dot{width:12px;height:12px;border-radius:50%;border:2px solid #000}
  .device-popup{font-size:13px;line-height:1.5}
  .device-popup strong{color:var(--accent);display:block;margin-bottom:4px;font-size:14px}
  .device-popup .coord{color:var(--muted);font-size:11px;font-family:monospace}
  .placement-marker{background:var(--success);color:#000;padding:4px 8px;border-radius:6px;font-weight:bold;font-size:11px;border:2px solid #000;box-shadow:0 2px 4px rgba(0,0,0,0.3)}
  .placement-marker.placed{background:#6b7280;opacity:0.5}
  
  /* Improved field markers */
  .field-cone{width:32px;height:32px;background:#ff6a00;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:14px;color:#fff;border:3px solid #000;box-shadow:0 2px 6px rgba(0,0,0,0.5);position:relative}
  .field-cone.placed{background:#6b7280;opacity:0.6}
  .field-cone::after{content:attr(data-num);position:absolute;bottom:-2px;right:-2px;background:#000;color:#fff;border-radius:50%;width:16px;height:16px;font-size:10px;display:flex;align-items:center;justify-content:center;border:2px solid #fff}
  
  .field-sign{width:36px;height:36px;background:#facc15;border-radius:4px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:18px;border:3px solid #000;box-shadow:0 2px 6px rgba(0,0,0,0.5);position:relative}
  .field-sign.placed{background:#6b7280;opacity:0.6}
  .field-sign::after{content:attr(data-num);position:absolute;bottom:-2px;right:-2px;background:#000;color:#fff;border-radius:50%;width:16px;height:16px;font-size:10px;display:flex;align-items:center;justify-content:center;border:2px solid #fff}
  
  .field-taper{background:#22c55e}
  .field-buffer{background:#f59e0b}
  
  /* Arrival notification */
  .arrival-banner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--success);color:#000;padding:20px 30px;border-radius:12px;font-size:20px;font-weight:bold;z-index:2000;box-shadow:0 8px 24px rgba(0,0,0,0.5);animation:popIn 0.3s ease;border:4px solid #fff}
  @keyframes popIn{from{transform:translate(-50%,-50%) scale(0.5);opacity:0} to{transform:translate(-50%,-50%) scale(1);opacity:1}}

  /* AR Mode */
  #arView{display:none;position:absolute;top:0;left:0;right:0;bottom:0;z-index:1500;background:#000}
  #arView.active{display:flex;flex-direction:column}
  #arCamera{width:100%;height:100%;object-fit:cover}
  .ar-overlay{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none}
  .ar-hud{position:absolute;top:20px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,0.9);padding:12px 20px;border-radius:12px;border:2px solid var(--accent);color:var(--text);text-align:center;font-weight:bold;backdrop-filter:blur(10px);max-width:90%}
  .ar-distance{font-size:32px;color:var(--accent);line-height:1}
  .ar-direction{font-size:14px;margin-top:4px;color:var(--muted)}
  .ar-tip{font-size:10px;margin-top:6px;color:#60a5fa;opacity:0.8}
  .ar-arrow{position:absolute;top:50%;left:50%;width:80px;height:80px;margin-left:-40px;margin-top:-40px;transition:transform 0.3s ease}
  .ar-arrow svg{width:100%;height:100%;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.5))}
  .ar-reticle{position:absolute;top:50%;left:50%;width:60px;height:60px;margin-left:-30px;margin-top:-30px;border:3px solid var(--accent);border-radius:50%;animation:pulse 1.5s ease-in-out infinite}
  @keyframes pulse{0%,100%{transform:scale(1);opacity:0.6} 50%{transform:scale(1.2);opacity:1}}
  
  /* AR Device Icons - 3D */
  .ar-device{position:absolute;transition:all 0.2s ease;pointer-events:none;z-index:10;transform-style:preserve-3d}
  .ar-device.current{animation:highlight 1s ease-in-out infinite}
  @keyframes highlight{0%,100%{filter:drop-shadow(0 4px 12px rgba(96,165,250,1)) drop-shadow(0 0 20px rgba(96,165,250,0.8))} 50%{filter:drop-shadow(0 4px 20px rgba(96,165,250,0.5))}}
  
  /* 3D Cone */
  .ar-cone-3d{width:60px;height:80px;position:relative;transform-style:preserve-3d}
  .cone-body{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:30px solid transparent;border-right:30px solid transparent;border-bottom:60px solid #ff6a00;filter:drop-shadow(2px 4px 6px rgba(0,0,0,0.5))}
  .cone-body::before{content:'';position:absolute;bottom:0;left:-30px;width:0;height:0;border-left:30px solid transparent;border-right:30px solid transparent;border-bottom:60px solid #d85500;opacity:0.6;transform:rotateY(45deg)}
  .cone-base-3d{position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:50px;height:12px;background:radial-gradient(ellipse at center, #8b3500 0%, #6b2700 100%);border-radius:50%;box-shadow:0 2px 8px rgba(0,0,0,0.6)}
  .cone-shadow{position:absolute;bottom:-5px;left:50%;transform:translateX(-50%);width:55px;height:8px;background:radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, transparent 70%);border-radius:50%}
  .cone-stripe{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);width:40px;height:8px;background:#fff;clip-path:polygon(0 0, 100% 0, 90% 100%, 10% 100%);opacity:0.9}
  
  /* Green taper cone */
  .ar-device.taper .cone-body{border-bottom-color:#22c55e}
  .ar-device.taper .cone-body::before{border-bottom-color:#16a34a}
  
  /* Orange buffer cone */
  .ar-device.buffer .cone-body{border-bottom-color:#f59e0b}
  .ar-device.buffer .cone-body::before{border-bottom-color:#d97706}
  
  /* 3D Sign */
  .ar-sign-3d{width:70px;height:90px;position:relative;transform-style:preserve-3d}
  .sign-post{position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:8px;height:50px;background:linear-gradient(to right, #666 0%, #888 50%, #666 100%);border-radius:4px;box-shadow:2px 2px 4px rgba(0,0,0,0.5)}
  .sign-post::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom, rgba(255,255,255,0.2) 0%, transparent 50%);border-radius:4px}
  .sign-panel{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);width:50px;height:50px;background:linear-gradient(135deg, #facc15 0%, #fde047 50%, #facc15 100%);border:4px solid #000;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:28px;box-shadow:0 4px 8px rgba(0,0,0,0.5), inset -2px -2px 4px rgba(0,0,0,0.2), inset 2px 2px 4px rgba(255,255,255,0.3);transform-style:preserve-3d}
  .sign-panel::before{content:'';position:absolute;top:-4px;left:-4px;right:-4px;bottom:-4px;border:2px solid rgba(255,255,255,0.3);border-radius:8px;pointer-events:none}
  .sign-shadow{position:absolute;bottom:-5px;left:50%;transform:translateX(-50%);width:60px;height:10px;background:radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, transparent 70%);border-radius:50%}
  
  .ar-device-label{position:absolute;bottom:-25px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,0.95);color:#fff;padding:3px 8px;border-radius:6px;font-size:11px;white-space:nowrap;font-weight:bold;border:1px solid rgba(96,165,250,0.5);box-shadow:0 2px 6px rgba(0,0,0,0.8)}
  .ar-device.placed{opacity:0.4;filter:grayscale(0.5)}
  
  /* Ground reference line */
  .ar-ground-line{position:absolute;left:0;right:0;height:2px;background:rgba(34,197,94,0.5);box-shadow:0 0 10px rgba(34,197,94,0.5);pointer-events:none}
  
  .ar-snap{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--success);color:#000;padding:24px 40px;border-radius:16px;font-size:24px;font-weight:bold;border:4px solid #fff;box-shadow:0 8px 24px rgba(0,0,0,0.8);animation:snapPulse 0.5s ease;z-index:100}
  @keyframes snapPulse{0%,100%{transform:translate(-50%,-50%) scale(1)} 50%{transform:translate(-50%,-50%) scale(1.1)}}
  .ar-controls{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:12px}
  .ar-controls button{padding:12px 24px;border-radius:12px;border:2px solid var(--accent);background:rgba(17,24,39,0.9);color:var(--text);font-weight:bold;font-size:14px;cursor:pointer;backdrop-filter:blur(10px)}
  .ar-controls button:active{background:var(--accent);color:#000}

  /* QR Preview Modal */
  .modal{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:9999;align-items:center;justify-content:center}
  .modal.active{display:flex}
  .modal-content{background:var(--panel);border-radius:12px;padding:20px;max-width:400px;width:90%;border:2px solid var(--accent)}
  .modal-header{font-size:18px;font-weight:bold;margin-bottom:12px;color:var(--accent)}
  .modal-body{text-align:center}
  .modal-footer{margin-top:16px;display:flex;gap:8px}
  .modal-footer button{flex:1}
</style>
</head>
<body>
<button class="mobile-toggle" id="mobileToggle">☰ Menu</button>

<div id="app">
  <aside id="sidebar">
    <div class="topline">
      <h1>Work Zone Planner <span class="badge">PRO</span></h1>
      <div class="inline-btns">
        <button id="btn-place" title="Place Cones">Place</button>
        <button id="btn-print" class="secondary" title="Generate & Print Plan">Print</button>
      </div>
    </div>
    <div class="sub">Professional work zone planning with MUTCD compliance, advanced features, and comprehensive reporting.</div>

    <!-- Address Search -->
    <div class="section">
      <div class="section-header" data-section="search">
        <div class="section-title">🔍 Location Search</div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="search">
        <label>Search Address or Place</label>
        <div style="display:flex;gap:6px">
          <input id="addressSearch" type="text" placeholder="e.g., 123 Main St, Portland ME" style="flex:1">
          <button id="btnSearch" class="secondary" style="width:60px;padding:6px">Go</button>
        </div>
        <div id="searchResults" style="margin-top:6px;font-size:11px;color:var(--muted)"></div>
        <div style="margin-top:8px;padding:6px;background:#1e293b;border-radius:6px;font-size:10px;color:var(--muted)">
          💡 <strong>Tip:</strong> Use the layer switcher (top right) to choose between Satellite, Hybrid (with labels), Street, or Topo maps. Zoom up to level 22 for detailed views.
        </div>
      </div>
    </div>

    <!-- Project Info Section -->
    <div class="section">
      <div class="section-header" data-section="project">
        <div class="section-title">📋 Project Information</div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="project">
        <label>Project Name</label>
        <input id="projectName" type="text" placeholder="e.g., Main St Repairs">
        <label style="margin-top:6px">Location</label>
        <input id="projectLocation" type="text" placeholder="e.g., SR-123, Mile Marker 45">
        <label style="margin-top:6px">Date</label>
        <input id="projectDate" type="text" value="">
      </div>
    </div>

    <!-- Speed & Spacing Section -->
    <div class="section">
      <div class="section-header" data-section="speed">
        <div class="section-title">⚡ Speed & Spacing</div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="speed">
        <div class="row">
          <div>
            <label>Speed Limit (mph) <span class="tooltip" title="Posted speed limit">ℹ️</span></label>
            <input id="speedLimit" type="number" value="35" min="10" max="80" step="5">
          </div>
          <div class="chk-row" style="align-self:end;justify-content:flex-start;padding-bottom:6px">
            <input type="checkbox" id="autoFromSpeed" checked>
            <label for="autoFromSpeed" style="margin:0">Auto buffer</label>
          </div>
        </div>

        <div class="radio-row">
          <label><input type="radio" name="taperMode" id="modeSingle" value="single" checked> Single</label>
          <label><input type="radio" name="taperMode" id="modeDouble" value="double"> Double</label>
          <span class="chk-row" style="margin-left:auto">
            <input type="checkbox" id="chk-delete">
            <label for="chk-delete" style="margin:0">Delete</label>
          </span>
        </div>

        <div class="row">
          <div>
            <label>Taper spacing (ft)</label>
            <input id="spacing" type="number" value="35" min="5" step="1">
          </div>
          <div>
            <label>Buffer spacing (ft)</label>
            <input id="bufferSpacing" type="number" value="70" min="10" step="5">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Icon scale</label>
            <input id="scale" type="number" value="1" min="0.5" max="2" step="0.1">
          </div>
          <div>
            <label>Station step (ft)</label>
            <input id="stationStep" type="number" value="50" min="25" step="25">
          </div>
        </div>
      </div>
    </div>

    <!-- Tools Section -->
    <div class="section">
      <div class="section-header" data-section="tools">
        <div class="section-title">🛠️ Tools</div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="tools">
        <div class="btns3">
          <button id="btn-measure" class="secondary" title="Measure Distance">📏 Measure</button>
          <button id="btn-clear-cones" class="secondary">Clear Cones</button>
          <button id="btn-clear-all" class="danger">Reset All</button>
        </div>
        <div class="btns3" style="margin-top:6px">
          <button id="btn-export-geojson" class="secondary">GeoJSON</button>
          <button id="btn-export-kml" class="secondary">KML</button>
          <button id="btn-export-csv" class="secondary">CSV</button>
        </div>
        <div style="margin-top:6px">
          <button id="btn-preview-qr" class="secondary" style="width:100%">📱 Preview Field QR</button>
        </div>
      </div>
    </div>

    <!-- Signs Section -->
    <div class="section">
      <div class="section-header" data-section="signs">
        <div class="section-title">🚧 Signs & Devices <span class="badge" id="signCount">0</span></div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="signs">
        <div id="palette" class="sign-palette">
          <div class="sign-pill" draggable="true" data-sign="ROAD WORK AHEAD">ROAD WORK AHEAD</div>
          <div class="sign-pill" draggable="true" data-sign="ONE LANE ROAD AHEAD">ONE LANE ROAD</div>
          <div class="sign-pill" draggable="true" data-sign="FLAGGER AHEAD">FLAGGER AHEAD</div>
          <div class="sign-pill" draggable="true" data-sign="FLAGGER">FLAGGER</div>
          <div class="sign-pill" draggable="true" data-sign="BE PREPARED TO STOP">PREP TO STOP</div>
          <div class="sign-pill" draggable="true" data-sign="DETOUR">DETOUR</div>
          <div class="sign-pill" draggable="true" data-sign="END ROAD WORK">END ROAD WORK</div>
          <div class="sign-pill" draggable="true" data-sign="LEFT LANE CLOSED">LEFT CLOSED</div>
          <div class="sign-pill" draggable="true" data-sign="RIGHT LANE CLOSED">RIGHT CLOSED</div>
          <div class="sign-pill" draggable="true" data-sign="MERGE LEFT">MERGE LEFT</div>
          <div class="sign-pill" draggable="true" data-sign="MERGE RIGHT">MERGE RIGHT</div>
          <div class="sign-pill" draggable="true" data-sign="SHOULDER WORK">SHOULDER WORK</div>
          <div class="sign-pill" draggable="true" data-sign="UTILITY WORK">UTILITY WORK</div>
          <div class="sign-pill" draggable="true" data-sign="ROAD CLOSED">ROAD CLOSED</div>
          <div class="sign-pill" draggable="true" data-sign="PED XING">PED XING</div>
          <div class="sign-pill" draggable="true" data-sign="SPEED LIMIT 25">SPEED 25</div>
          <div class="sign-pill" draggable="true" data-sign="SPEED LIMIT 35">SPEED 35</div>
          <div class="sign-pill" draggable="true" data-sign="SPEED LIMIT 45">SPEED 45</div>
          <div class="sign-pill" draggable="true" data-sign="BARRICADE 8 FT">BARRICADE 8FT</div>
          <div class="sign-pill" draggable="true" data-sign="ARROW BOARD">ARROW BOARD</div>
          <div class="sign-pill" draggable="true" data-sign="CHANGEABLE MESSAGE">MSG SIGN</div>
        </div>
        <button id="btn-clear-signs" class="secondary" style="margin-top:6px;width:100%">Clear All Signs</button>
      </div>
    </div>

    <!-- Statistics Section -->
    <div class="section">
      <div class="section-header" data-section="stats">
        <div class="section-title">📊 Statistics & Compliance</div>
        <span class="section-icon">▼</span>
      </div>
      <div class="section-content" data-section="stats">
        <div class="stat" id="statProjectLength">Project Length: —</div>
        <div class="stat" id="statTaperA">Taper A: —</div>
        <div class="stat" id="statTaperB">Taper B: —</div>
        <div class="stat" id="statBuffer">Buffer: —</div>
        <div class="stat" id="statAdvWarning">Adv. Warning: —</div>
        <div class="stat" id="statCones">Cones: <strong>0</strong></div>
        <div class="stat" id="statSigns">Signs: <strong>0</strong></div>
        <div class="stat" id="statEstCost" style="margin-top:8px;background:#1e293b">Est. Cost: <strong>—</strong></div>
      </div>
    </div>

  </aside>

  <div id="map"></div>
</div>

<!-- Print Panel -->
<div class="print-panel" id="printPanel">
  <h2>Traffic Management Plan</h2>
  <div style="margin-bottom:12px;font-size:13px">
    <div><strong>Project:</strong> <span id="ppProjectName">—</span></div>
    <div><strong>Location:</strong> <span id="ppLocation">—</span></div>
    <div><strong>Date:</strong> <span id="ppDate">—</span></div>
    <div><strong>Speed Limit:</strong> <span id="ppSpeed">—</span> mph</div>
  </div>

  <div class="cols">
    <div>
      <h3>Device Inventory</h3>
      <table id="printDeviceTable">
        <thead><tr><th>Device</th><th>Quantity</th></tr></thead>
        <tbody id="printDevices"></tbody>
      </table>
    </div>
    <div>
      <h3>Cone Placement Details</h3>
      <table>
        <tr><th>Taper Spacing</th><td id="ppTaperSpacing">—</td></tr>
        <tr><th>Taper Cones</th><td id="ppTaperCones">0</td></tr>
        <tr><th>Buffer Spacing</th><td id="ppBufferSpacing">—</td></tr>
        <tr><th>Buffer Cones</th><td id="ppBufferCones">0</td></tr>
        <tr><th>Total Cones</th><td id="ppTotalCones">0</td></tr>
      </table>
    </div>
  </div>

  <h3>MUTCD Compliance Summary</h3>
  <div id="ppCompliance" style="font-size:12px;line-height:1.6"></div>

  <h3>Project Measurements</h3>
  <div id="ppMeasurements" style="font-size:12px"></div>

  <div class="qr-section">
    <h3>📱 GPS-Guided Field Setup</h3>
    <div style="margin:10px 0">
      <div id="qrcode" style="display:inline-block"></div>
    </div>
    <p style="font-size:13px;margin:8px 0;max-width:500px;margin-left:auto;margin-right:auto;line-height:1.5">
      <strong>Scan this QR code</strong> with your mobile device for GPS-guided placement:
    </p>
    <ul style="font-size:12px;text-align:left;max-width:500px;margin:8px auto;line-height:1.6">
      <li><strong>Real-time navigation:</strong> Turn-by-turn directions to each device</li>
      <li><strong>Distance tracking:</strong> Live distance updates in feet</li>
      <li><strong>Compass guidance:</strong> Visual arrow pointing to target location</li>
      <li><strong>Arrival alerts:</strong> Vibration and notification when within 10 feet</li>
      <li><strong>Progress tracking:</strong> Mark devices as placed, auto-advance to next</li>
    </ul>
  </div>
</div>

<!-- Field View (Mobile) -->
<div id="fieldView">
  <div class="field-header">
    <h2 id="fieldProjectName">Work Zone Setup</h2>
    <div class="info" id="fieldProjectInfo">Loading project information...</div>
  </div>
  
  <!-- Device Filter Bar -->
  <div class="filter-bar">
    <button class="filter-btn active" data-filter="all">🎯 All Devices</button>
    <button class="filter-btn taper" data-filter="taper">🟢 Taper Cones</button>
    <button class="filter-btn buffer" data-filter="buffer">🟠 Buffer Cones</button>
    <button class="filter-btn sign" data-filter="sign">🟡 Signs</button>
  </div>
  
  <div id="fieldViewMap">
    <!-- Navigation Panel -->
    <div id="navPanel" class="nav-panel hidden">
      <div class="nav-distance" id="navDistance">—</div>
      <div class="nav-direction" id="navDirection">
        <span id="navArrowText">⬆️</span>
        <span id="navDirectionText">Calculating route...</span>
      </div>
      <div class="nav-device" id="navDevice">
        Target: <strong id="navDeviceName">—</strong>
      </div>
    </div>
    
    <!-- Compass Arrow -->
    <div id="compassContainer" class="compass-container" style="display:none">
      <div class="compass-arrow" id="compassArrow">⬆️</div>
      <div class="compass-accuracy" id="compassAccuracy">Calculating...</div>
    </div>
  </div>
  <div class="field-controls">
    <button id="btnLocateMe" class="secondary">📍 Start GPS</button>
    <button id="btnARMode" class="secondary">📷 AR Mode</button>
    <button id="btnNextDevice" style="background:var(--accent)">→ Next Device</button>
    <button id="btnExitField" class="secondary">Exit Setup</button>
    <div class="field-legend">
      <div class="field-legend-item">
        <div class="field-legend-dot" style="background:#22c55e"></div>
        <span>Taper</span>
      </div>
      <div class="field-legend-item">
        <div class="field-legend-dot" style="background:#f59e0b"></div>
        <span>Buffer</span>
      </div>
      <div class="field-legend-item">
        <div class="field-legend-dot" style="background:#facc15"></div>
        <span>Sign</span>
      </div>
      <div class="field-legend-item">
        <div class="field-legend-dot" style="background:#6b7280"></div>
        <span>Placed</span>
      </div>
      <div style="flex-basis:100%;text-align:center;font-size:10px;color:var(--muted);margin-top:4px">
        💡 Use filter buttons to focus on device types<br>
        🔊 Audio alerts play when you arrive (within 10 ft)<br>
        📷 AR Mode shows 3D cones/signs on ground exactly where they belong
      </div>
    </div>
  </div>
  
  <!-- AR View -->
  <div id="arView">
    <video id="arCamera" autoplay playsinline></video>
    <div class="ar-overlay">
      <div class="ar-hud">
        <div class="ar-distance" id="arDistance">—</div>
        <div class="ar-direction" id="arDirection">Initializing...</div>
        <div class="ar-tip">📱 Point camera at ground to see placement spots</div>
      </div>
      <div id="arDeviceContainer"></div>
      <div class="ar-reticle"></div>
      <div class="ar-arrow" id="arArrow">
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="arrowGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#22c55e;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#10b981;stop-opacity:1" />
            </linearGradient>
          </defs>
          <path d="M 50 10 L 70 40 L 58 40 L 58 90 L 42 90 L 42 40 L 30 40 Z" 
                fill="url(#arrowGrad)" stroke="#fff" stroke-width="2"/>
        </svg>
      </div>
      <div id="arSnap" class="ar-snap" style="display:none">✓ PERFECT!</div>
    </div>
    <div class="ar-controls">
      <button id="btnARPlace">✓ Place Here</button>
      <button id="btnARClose">Exit AR</button>
    </div>
  </div>
</div>

<!-- QR Preview Modal -->
<div id="qrModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">📱 GPS-Guided Field Setup</div>
    <div class="modal-body">
      <div id="qrPreview"></div>
      <p style="font-size:12px;margin:12px 0;color:var(--muted);line-height:1.5">
        Scan this QR code with your mobile device to launch GPS-guided navigation. The field crew will get turn-by-turn directions, real-time distance tracking, and arrival notifications for every cone and sign placement location.
      </p>
    </div>
    <div class="modal-footer">
      <button id="btnCloseModal" class="secondary">Close</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tokml/0.4.0/tokml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

<script>
const FT_TO_M = 0.3048;
const LANE_WIDTH_FT = 12;

// Device costs (rough estimates in USD)
const DEVICE_COSTS = {
  'Cone': 15,
  'ROAD WORK AHEAD': 150,
  'FLAGGER': 0, // personnel
  'BARRICADE 8 FT': 75,
  'ARROW BOARD': 2500,
  'CHANGEABLE MESSAGE': 8000,
  'default': 100
};

// Map with multiple basemap options
const map = L.map('map', { minZoom: 3, maxZoom: 22 }).setView([39.5,-98.35], 5);

// Define basemap layers
const baseLayers = {
  'Satellite': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri',
    maxZoom: 22
  }),
  'Hybrid (Labels)': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri',
    maxZoom: 22
  }),
  'Street Map': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors',
    maxZoom: 19
  }),
  'Topo Map': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri',
    maxZoom: 19
  })
};

// Street labels overlay for Hybrid mode
const streetLabels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
  attribution: '',
  maxZoom: 22
});

// Add default layer
baseLayers['Satellite'].addTo(map);

// Layer control
const layerControl = L.control.layers(baseLayers, null, {
  position: 'topright',
  collapsed: false
}).addTo(map);

// Add scale bar (shows distance in feet and meters)
L.control.scale({
  position: 'bottomleft',
  imperial: true,
  metric: true
}).addTo(map);

// Handle Hybrid layer - add labels when selected
map.on('baselayerchange', function(e) {
  if (e.name === 'Hybrid (Labels)') {
    streetLabels.addTo(map);
  } else {
    if (map.hasLayer(streetLabels)) {
      map.removeLayer(streetLabels);
    }
  }
});

// Layers
const drawnItems = new L.FeatureGroup().addTo(map);
const coneLayer  = new L.FeatureGroup().addTo(map);
const labelLayer = new L.FeatureGroup().addTo(map);
const signLayer  = new L.FeatureGroup().addTo(map);
const badgeLayer = new L.FeatureGroup().addTo(map);
const measureLayer = new L.FeatureGroup().addTo(map);

let line = null;
let measureMode = false;
let measurePoints = [];

// Draw controls
const drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems },
  draw: { polygon:false, rectangle:false, circle:false, marker:false, circlemarker:false,
    polyline:{shapeOptions:{color:'#22d3ee',weight:4}}
  }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, e => {
  if (e.layerType === 'polyline') {
    if (line) drawnItems.removeLayer(line);
    line = e.layer;
    drawnItems.addLayer(line);
    map.fitBounds(line.getBounds(), {padding:[20,20]});
    updateStats();
    updateBadges();
  }
});
map.on('draw:edited', () => { updateStats(); updateBadges(); });

// DOM elements
const speedEl = document.getElementById('speedLimit');
const autoFromSpeedEl = document.getElementById('autoFromSpeed');
const spacingEl = document.getElementById('spacing');
const bufferSpacingEl = document.getElementById('bufferSpacing');
const scaleEl = document.getElementById('scale');
const stationStepEl = document.getElementById('stationStep');
const modeSingleEl = document.getElementById('modeSingle');
const modeDoubleEl = document.getElementById('modeDouble');
const chkDeleteEl = document.getElementById('chk-delete');

// Collapsible sections
document.querySelectorAll('.section-header').forEach(header => {
  header.addEventListener('click', () => {
    const section = header.getAttribute('data-section');
    const content = document.querySelector(`.section-content[data-section="${section}"]`);
    const icon = header.querySelector('.section-icon');
    content.classList.toggle('collapsed');
    icon.classList.toggle('collapsed');
  });
});

// Mobile toggle
document.getElementById('mobileToggle').addEventListener('click', () => {
  document.getElementById('sidebar').classList.toggle('mobile-hidden');
});

// Set today's date
document.getElementById('projectDate').value = new Date().toLocaleDateString();

// Metrics
let lastTaperSpacingFt = null;
let lastBufferSpacingFt = null;
let lastTaperCones = 0;
let lastBufferCones = 0;

// Speed-based calculations
function getMutcdBufferSpacingFt(speed){
  const s = Math.max(10, Math.min(85, +speed||0));
  if (s <= 25) return 25;
  if (s <= 60) return Math.round(s/5)*5;
  return 65;
}
function getStationIntervalFt(speed){
  return (+speed <= 35 ? 25 : 50);
}
function getAdvanceWarningDistance(speed){
  const s = +speed || 0;
  if (s <= 25) return 100;
  if (s <= 35) return 350;
  if (s <= 45) return 500;
  if (s <= 55) return 750;
  return 1000;
}
function handleSpeedChange(){
  const s = +speedEl.value || 0;
  if (autoFromSpeedEl.checked){
    bufferSpacingEl.value = getMutcdBufferSpacingFt(s);
    stationStepEl.value = getStationIntervalFt(s);
  }
  updateBadges();
  updateStats();
}
speedEl.addEventListener('input', handleSpeedChange);
autoFromSpeedEl.addEventListener('input', handleSpeedChange);
modeSingleEl.addEventListener('input', () => { updateBadges(); updateStats(); });
modeDoubleEl.addEventListener('input', () => { updateBadges(); updateStats(); });

// Format helpers
function fmtFt(ft){ return ft ? `${Math.round(ft).toLocaleString()} ft` : '—'; }
function fmtCurrency(val){ return val ? `$${Math.round(val).toLocaleString()}` : '—'; }

// Update statistics
function updateStats(){
  let buffer=0, totalLength=0;
  if (line){
    const gj = line.toGeoJSON();
    const C = gj.geometry.coordinates;
    totalLength = turf.length(gj, {units:'meters'})/FT_TO_M;
    
    if (C.length >= 2){
      if (C.length > 2){
        if (modeDoubleEl.checked && C.length >= 3){
          if (C.length > 3){
            const bufferCoords = C.slice(1, C.length-1);
            if (bufferCoords.length >= 2){
              const lsBuf = {type:'Feature', geometry:{type:'LineString', coordinates: bufferCoords}};
              buffer = turf.length(lsBuf,{units:'meters'})/FT_TO_M;
            }
          }
        } else {
          const lsBuf = {type:'Feature', geometry:{type:'LineString', coordinates: C.slice(1)}};
          buffer = turf.length(lsBuf,{units:'meters'})/FT_TO_M;
        }
      }
    }
  }
  
  const coneCount = coneLayer.getLayers().length;
  const signCount = countSignItems();
  const speed = +speedEl.value || 35;
  const reqAdvWarning = getAdvanceWarningDistance(speed);
  
  document.getElementById('statProjectLength').innerHTML = `Project Length: <strong>${fmtFt(totalLength)}</strong>`;
  document.getElementById('statBuffer').innerHTML = `Buffer: <strong>${fmtFt(buffer)}</strong>`;
  document.getElementById('statCones').innerHTML = `Cones: <strong>${coneCount}</strong>`;
  document.getElementById('statSigns').innerHTML = `Signs: <strong>${signCount}</strong>`;
  document.getElementById('statAdvWarning').innerHTML = `Adv. Warning: <strong>${reqAdvWarning} ft</strong> required`;
  document.getElementById('signCount').textContent = signCount;
  
  // Cost estimation
  const coneCost = coneCount * DEVICE_COSTS['Cone'];
  let signCost = 0;
  const signCounts = getSignCounts();
  for (const [name, count] of Object.entries(signCounts)){
    signCost += count * (DEVICE_COSTS[name] || DEVICE_COSTS['default']);
  }
  const totalCost = coneCost + signCost;
  document.getElementById('statEstCost').innerHTML = `Est. Cost: <strong>${fmtCurrency(totalCost)}</strong>`;
}

// Place cones
function placeCones(){
  if (!line){ alert('Draw the polyline first.'); return; }

  coneLayer.clearLayers();
  labelLayer.clearLayers();

  const spacingFt = +spacingEl.value || 35;
  const bufferSpacingFt = +bufferSpacingEl.value || spacingFt;
  const scale = +scaleEl.value || 1;
  const stationStep = +stationStepEl.value || 50;
  const doubleTaper = modeDoubleEl.checked;

  lastBufferSpacingFt = bufferSpacingFt;
  lastTaperSpacingFt = null;
  lastTaperCones = 0;
  lastBufferCones = 0;

  const gj = line.toGeoJSON();
  const C = gj.geometry.coordinates;
  if (C.length < 2){ alert('Polyline needs at least two points.'); return; }

  function addCone(latlng, title){
    const icon = L.divIcon({html:`<div class="cone" style="transform:translate(-8px,-20px) scale(${scale});"></div>`,iconSize:[0,0]});
    const m = L.marker(latlng, {icon, title});
    m.on('click', ()=>{ if (chkDeleteEl.checked) { coneLayer.removeLayer(m); updateStats(); } });
    coneLayer.addLayer(m);
  }

  function placeTaper(ls, titlePrefix){
    const Lm = turf.length(ls,{units:'meters'});
    const Lft = Lm/FT_TO_M;
    if (Lm <= 0) return;
    const maxSpacingForFiveFt = Lft/4;
    const useOverride = spacingFt > maxSpacingForFiveFt;
    const spacingM = (useOverride ? (Lft/4) : spacingFt) * FT_TO_M;

    let pts = [];
    if (useOverride){
      for (let i=0;i<5;i++){ pts.push(turf.along(ls, (i/4)*Lm,{units:'meters'})); }
      lastTaperSpacingFt = maxSpacingForFiveFt;
    } else {
      const n = Math.floor(Lm/spacingM);
      for (let i=0;i<=n;i++){
        const d = Math.min(i*spacingM,Lm);
        pts.push(turf.along(ls, d, {units:'meters'}));
      }
      if (pts.length < 5){
        pts = [];
        for (let i=0;i<5;i++){ pts.push(turf.along(ls, (i/4)*Lm, {units:'meters'})); }
        lastTaperSpacingFt = maxSpacingForFiveFt;
      } else {
        lastTaperSpacingFt = spacingFt;
      }
    }
    pts.forEach((pt, idx)=> addCone(L.latLng(pt.geometry.coordinates[1], pt.geometry.coordinates[0]), `${titlePrefix} ${idx+1}`));
    lastTaperCones += pts.length;
  }

  function placeBuffer(coords){
    const spacingM = bufferSpacingFt*FT_TO_M;
    for (let i=0;i<coords.length-1;i++){
      const seg = {type:'Feature', geometry:{type:'LineString', coordinates:[coords[i], coords[i+1]]}};
      const Lm = turf.length(seg,{units:'meters'});
      if (Lm <= 0) continue;
      const n = Math.floor(Lm/spacingM);
      for (let k=1;k<=n;k++){
        const d = k*spacingM;
        if (d >= Lm) break;
        const pt = turf.along(seg, d, {units:'meters'});
        addCone(L.latLng(pt.geometry.coordinates[1], pt.geometry.coordinates[0]), `Buffer ${i+1}-${k}`);
        lastBufferCones++;
      }
    }
  }

  const lsA = {type:'Feature', geometry:{type:'LineString', coordinates:[C[0], C[1]]}};
  placeTaper(lsA, 'Taper A');

  if (C.length > 2){
    if (doubleTaper && C.length >= 3){
      const lsB = {type:'Feature', geometry:{type:'LineString', coordinates:[C[C.length-2], C[C.length-1]]}};
      placeTaper(lsB, 'Taper B');
      if (C.length > 3){
        const bufferCoords = C.slice(1, C.length-1);
        if (bufferCoords.length >= 2) placeBuffer(bufferCoords);
      }
    } else {
      placeBuffer(C.slice(1));
    }
  }

  // Station labels
  const totalLenM = turf.length(gj, {units:'meters'});
  for (let d=stationStep*FT_TO_M; d<totalLenM; d+=stationStep*FT_TO_M){
    const pt = turf.along(gj, d, {units:'meters'});
    const latlng = L.latLng(pt.geometry.coordinates[1], pt.geometry.coordinates[0]);
    const lbl=L.divIcon({className:'',html:`<div class="station-label">${Math.round(d/FT_TO_M)} ft</div>`});
    const m = L.marker(latlng,{icon:lbl});
    m.on('click', ()=>{ if (chkDeleteEl.checked) { labelLayer.removeLayer(m); updateStats(); } });
    labelLayer.addLayer(m);
  }

  updateStats();
  updateBadges();
}

// Measure tool
function toggleMeasure(){
  measureMode = !measureMode;
  const btn = document.getElementById('btn-measure');
  if (measureMode){
    btn.style.background = 'var(--success)';
    btn.textContent = '✓ Measuring';
    map.getContainer().style.cursor = 'crosshair';
    measurePoints = [];
  } else {
    btn.style.background = '';
    btn.textContent = '📏 Measure';
    map.getContainer().style.cursor = '';
    measureLayer.clearLayers();
    measurePoints = [];
  }
}

map.on('click', (e) => {
  if (!measureMode) return;
  measurePoints.push(e.latlng);
  
  if (measurePoints.length === 1){
    L.circleMarker(e.latlng, {radius:5, color:'#22c55e', fillColor:'#22c55e', fillOpacity:1}).addTo(measureLayer);
  } else if (measurePoints.length === 2){
    const p1 = measurePoints[0];
    const p2 = measurePoints[1];
    const line = L.polyline([p1, p2], {color:'#22c55e', weight:3, dashArray:'5,5'}).addTo(measureLayer);
    
    const gj = {type:'Feature', geometry:{type:'LineString', coordinates:[[p1.lng, p1.lat], [p2.lng, p2.lat]]}};
    const distM = turf.length(gj, {units:'meters'});
    const distFt = distM / FT_TO_M;
    
    const midpoint = L.latLng((p1.lat + p2.lat)/2, (p1.lng + p2.lng)/2);
    const lbl = L.divIcon({className:'', html:`<div class="measure-label">${Math.round(distFt)} ft</div>`});
    L.marker(midpoint, {icon: lbl}).addTo(measureLayer);
    
    L.circleMarker(p2, {radius:5, color:'#22c55e', fillColor:'#22c55e', fillOpacity:1}).addTo(measureLayer);
    
    measurePoints = [];
  }
});

// Barricade
function createBarricade(centerLL, options={}){
  let angle = options.angle || 0;
  const lenM = 8 * FT_TO_M;
  const widthM = 0.5 * FT_TO_M;

  function build(center, angDeg){
    function dest(from, distM, bearingDeg){
      return turf.rhumbDestination(from, distM/1000, bearingDeg, {units:'kilometers'}).geometry.coordinates;
    }
    const centerPt = turf.point([center.lng, center.lat]);
    const A = dest(centerPt,  lenM/2, angDeg);
    const B = dest(centerPt, -lenM/2, angDeg);
    const left = angDeg - 90, right = angDeg + 90;
    const A_left  = dest(turf.point(A),  widthM/2, left);
    const A_right = dest(turf.point(A),  widthM/2, right);
    const B_left  = dest(turf.point(B),  widthM/2, left);
    const B_right = dest(turf.point(B),  widthM/2, right);
    const ring = [A_left, A_right, B_right, B_left, A_left];
    return ring.map(c=>[c[1],c[0]]);
  }

  const ringLL = build(centerLL, angle);
  const poly = L.polygon(ringLL, {color:'#111827', weight:2, fill:true, fillColor:'#f97316', fillOpacity:0.9}).addTo(signLayer);

  const handle = L.marker(centerLL, {draggable:true, icon: L.divIcon({className:'', html:'<div class="handle">8ft</div>', iconSize:[0,0]})}).addTo(signLayer);
  handle.on('dragend', ()=>{
    const ll = handle.getLatLng();
    poly.setLatLngs(build(ll, angle));
  });

  const rotIcon = L.divIcon({className:'', html:'<div class="rot-toolbar"><button class="rot-btn" data-d="-15">⟲ 15°</button><button class="rot-btn" data-d="15">⟳ 15°</button></div>'});
  const toolbar = L.marker(centerLL, {icon: rotIcon, draggable:false}).addTo(signLayer);

  function syncToolbar(){ toolbar.setLatLng(handle.getLatLng()); }
  handle.on('drag', syncToolbar);
  syncToolbar();

  toolbar.on('click', (e)=>{
    const target = e.originalEvent.target;
    if (target && target.classList && target.classList.contains('rot-btn')){
      const delta = parseFloat(target.getAttribute('data-d'));
      angle = (angle + delta) % 360;
      poly.setLatLngs(build(handle.getLatLng(), angle));
    }
  });

  const del = ()=>{ if (chkDeleteEl.checked){ signLayer.removeLayer(poly); signLayer.removeLayer(handle); signLayer.removeLayer(toolbar); updateStats(); } };
  poly.on('click', del); handle.on('click', del);

  updateStats();
}

function countSignItems(){
  let count = 0;
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const el = l.getElement && l.getElement();
      if (el && (el.querySelector('.sign-pill') || el.querySelector('.flagger-icon') || el.querySelector('.arrow-board'))) count++;
    } else if (l instanceof L.Polygon) count++;
    else if (l instanceof L.Circle) count++;
  });
  return count;
}

function getSignCounts(){
  const counts = {};
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const el = l.getElement && l.getElement();
      if (el && el.querySelector('.sign-pill')){
        const text = el.innerText.trim();
        counts[text] = (counts[text]||0)+1;
      } else if (el && el.querySelector('.flagger-icon')){
        counts['FLAGGER'] = (counts['FLAGGER']||0)+1;
      } else if (el && el.querySelector('.arrow-board')){
        counts['ARROW BOARD'] = (counts['ARROW BOARD']||0)+1;
      }
    } else if (l instanceof L.Polygon){
      counts['BARRICADE 8 FT'] = (counts['BARRICADE 8 FT']||0)+1;
    } else if (l instanceof L.Circle){
      counts['ADVANCE WARNING AREA'] = (counts['ADVANCE WARNING AREA']||0)+1;
    }
  });
  return counts;
}

// Signs drag & drop
let draggedSignText = null;
document.getElementById('palette').addEventListener('dragstart', (e)=>{
  const t = e.target.closest('.sign-pill');
  if (!t) return;
  draggedSignText = t.getAttribute('data-sign');
  e.dataTransfer.setData('text/plain', draggedSignText);
});
document.getElementById('map').addEventListener('dragover', (e)=> e.preventDefault());
document.getElementById('map').addEventListener('drop', (e)=>{
  e.preventDefault();
  const text = e.dataTransfer.getData('text/plain') || draggedSignText;
  if (!text) return;
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const latlng = map.containerPointToLatLng([x,y]);

  if (text === 'BARRICADE 8 FT'){
    createBarricade(latlng, {angle:0});
    return;
  }

  if (text === 'ARROW BOARD'){
    const html = '<div class="arrow-board"><div class="arrow-segment"></div><div class="arrow-segment"></div><div class="arrow-segment"></div></div>';
    const icon = L.divIcon({className:'', html, iconSize:[0,0]});
    const m = L.marker(latlng, {icon, draggable:true});
    m.on('click', ()=>{ if (chkDeleteEl.checked) { signLayer.removeLayer(m); updateStats(); } });
    signLayer.addLayer(m);
    updateStats();
    return;
  }

  if (text === 'CHANGEABLE MESSAGE'){
    const html = '<div style="background:#000;border:3px solid #f59e0b;padding:4px 8px;border-radius:4px;color:#f59e0b;font-weight:bold;font-size:10px;font-family:monospace">MESSAGE<br>SIGN</div>';
    const icon = L.divIcon({className:'', html, iconSize:[0,0]});
    const m = L.marker(latlng, {icon, draggable:true});
    m.on('click', ()=>{ if (chkDeleteEl.checked) { signLayer.removeLayer(m); updateStats(); } });
    signLayer.addLayer(m);
    updateStats();
    return;
  }

  if (text === 'FLAGGER'){
    const scale = +scaleEl.value || 1;
    const html = `
      <div class="flagger-icon" style="display:flex;align-items:center;gap:6px;transform:scale(${scale});">
        <div style="width:14px;height:14px;background:#ef4444;border:2px solid #fff;clip-path:polygon(30% 0,70% 0,100% 30%,100% 70%,70% 100%,30% 100%,0 70%,0 30%);box-shadow:0 0 0 1px #000"></div>
        <div style="position:relative;width:2px;height:22px;background:#000;margin-left:-2px"></div>
        <div style="width:10px;height:18px;background:#000;border-radius:2px;margin-left:6px;position:relative;">
          <div style="position:absolute;top:-8px;left:2px;width:6px;height:6px;background:#000;border-radius:50%"></div>
          <div style="position:absolute;top:6px;left:-6px;width:6px;height:2px;background:#000"></div>
          <div style="position:absolute;top:6px;right:-6px;width:6px;height:2px;background:#000"></div>
        </div>
      </div>`;
    const icon = L.divIcon({className:'', html, iconSize:[0,0]});
    const m = L.marker(latlng, {icon, draggable:true});
    m.on('click', ()=>{ if (chkDeleteEl.checked) { signLayer.removeLayer(m); updateStats(); } });
    signLayer.addLayer(m);
    updateStats();
    return;
  }

  const icon = L.divIcon({className:'',html:`<div class="sign-pill" style="cursor:move">${text}</div>`});
  const m = L.marker(latlng, {icon, draggable:true});

  let circle = null;
  if (text === 'ROAD WORK AHEAD'){
    const speed = +speedEl.value || 35;
    const radiusFt = getAdvanceWarningDistance(speed);
    const radiusM = radiusFt * FT_TO_M;
    circle = L.circle(latlng, {
      radius: radiusM,
      color:'#f97316',
      fillColor:'#f97316',
      fillOpacity:0.25,
      weight:1
    }).addTo(signLayer);
    m._rwCircle = circle;
    m.on('drag', () => {
      if (m._rwCircle) m._rwCircle.setLatLng(m.getLatLng());
    });
  }

  m.on('click', ()=>{ 
    if (chkDeleteEl.checked) { 
      if (m._rwCircle) signLayer.removeLayer(m._rwCircle);
      signLayer.removeLayer(m); 
      updateStats(); 
    } 
  });

  signLayer.addLayer(m);
  updateStats();
});

// MUTCD compliance
function calcRequiredTaperLength(speed){
  const s = +speed || 0;
  if (s < 40) return (LANE_WIDTH_FT * s) / 60;
  return (LANE_WIDTH_FT * (s * s)) / 60;
}

function createBadge(latlng, text, status, formulaText){
  const className = status === 'good' ? '' : (status === 'warning' ? 'warning' : 'short');
  const el = L.divIcon({className:'', html:`<div class="taper-badge ${className}">${text}</div>`});
  const m = L.marker(latlng, {icon: el});
  m.on('click', ()=>{
    const color = status === 'good' ? '#22c55e' : (status === 'warning' ? '#f59e0b' : '#ef4444');
    const symbol = status === 'good' ? '✓' : (status === 'warning' ? '⚠' : '✗');
    const label = status === 'good' ? 'MUTCD Compliant' : (status === 'warning' ? 'Warning' : 'Not Compliant');
    const popupText = `<div style="font-size:12px;">
      <div style="font-weight:bold;color:${color}">${symbol} ${label}</div>
      ${formulaText}
    </div>`;
    m.bindPopup(popupText, {className:'dark-popup', autoClose:true, closeOnClick:true}).openPopup();
  });
  return m;
}

function updateBadges(){
  badgeLayer.clearLayers();
  if (!line) {
    document.getElementById('statTaperA').innerHTML = 'Taper A: —';
    document.getElementById('statTaperB').innerHTML = 'Taper B: —';
    return;
  }
  const speed = +speedEl.value || 0;
  const required = calcRequiredTaperLength(speed);
  const C = line.toGeoJSON().geometry.coordinates;
  if (C.length < 2) return;

  const segA = {type:'Feature', geometry:{type:'LineString', coordinates:[C[0],C[1]]}};
  const LmA = turf.length(segA, {units:'meters'});
  const LftA = LmA/FT_TO_M;
  const midA = turf.along(segA, LmA/2, {units:'meters'});
  const goodA = LftA >= required;
  const warningA = LftA >= required * 0.9 && LftA < required;
  const status = goodA ? 'good' : (warningA ? 'warning' : 'bad');
  const diffA = Math.round(Math.abs(LftA - required));
  const badgeTextA = goodA ? `✓ ${Math.round(LftA)} ft` : (warningA ? `⚠ ${Math.round(LftA)} ft` : `✗ Short ${diffA} ft`);
  const formulaTextA = `<div>Required: ${Math.round(required)} ft<br>Actual: ${Math.round(LftA)} ft<br>W=12 ft, S=${speed} mph</div>`;
  badgeLayer.addLayer(createBadge(L.latLng(midA.geometry.coordinates[1], midA.geometry.coordinates[0]), badgeTextA, status, formulaTextA));
  document.getElementById('statTaperA').innerHTML = `Taper A: <strong>${Math.round(LftA)} ft</strong> ${goodA ? '(✓ MUTCD)' : warningA ? '(⚠ Close)' : '(✗ -' + diffA + ' ft)'}`;

  if (modeDoubleEl.checked && C.length >= 3){
    const segB = {type:'Feature', geometry:{type:'LineString', coordinates:[C[C.length-2], C[C.length-1]]}};
    const LmB = turf.length(segB, {units:'meters'});
    const LftB = LmB/FT_TO_M;
    const midB = turf.along(segB, LmB/2, {units:'meters'});
    const goodB = LftB >= required;
    const warningB = LftB >= required * 0.9 && LftB < required;
    const statusB = goodB ? 'good' : (warningB ? 'warning' : 'bad');
    const diffB = Math.round(Math.abs(LftB - required));
    const badgeTextB = goodB ? `✓ ${Math.round(LftB)} ft` : (warningB ? `⚠ ${Math.round(LftB)} ft` : `✗ Short ${diffB} ft`);
    const formulaTextB = `<div>Required: ${Math.round(required)} ft<br>Actual: ${Math.round(LftB)} ft<br>W=12 ft, S=${speed} mph</div>`;
    badgeLayer.addLayer(createBadge(L.latLng(midB.geometry.coordinates[1], midB.geometry.coordinates[0]), badgeTextB, statusB, formulaTextB));
    document.getElementById('statTaperB').innerHTML = `Taper B: <strong>${Math.round(LftB)} ft</strong> ${goodB ? '(✓ MUTCD)' : warningB ? '(⚠ Close)' : '(✗ -' + diffB + ' ft)'}`;
  } else {
    document.getElementById('statTaperB').innerHTML = 'Taper B: —';
  }
}

// Export functions
function exportGeoJSON(){
  const features = [];
  if (line) features.push(line.toGeoJSON());
  coneLayer.eachLayer(m => features.push({
    type:'Feature', properties:{name:m.options.title||'Cone', type:'cone'},
    geometry:{type:'Point', coordinates:[m.getLatLng().lng, m.getLatLng().lat]}
  }));
  labelLayer.eachLayer(m => {
    const text = m.getElement() ? m.getElement().innerText : 'Station';
    features.push({ type:'Feature', properties:{name:text, type:'label'},
      geometry:{type:'Point', coordinates:[m.getLatLng().lng, m.getLatLng().lat]} });
  });
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const el = l.getElement && l.getElement();
      let name = 'Sign';
      if (el && el.querySelector('.sign-pill')) name = el.innerText.trim();
      else if (el && el.querySelector('.flagger-icon')) name = 'FLAGGER';
      else if (el && el.querySelector('.arrow-board')) name = 'ARROW BOARD';
      features.push({
        type:'Feature', properties:{name, type:'sign'},
        geometry:{type:'Point', coordinates:[l.getLatLng().lng, l.getLatLng().lat]}
      });
    } else if (l instanceof L.Polygon || l instanceof L.Polyline){
      features.push(l.toGeoJSON());
    } else if (l instanceof L.Circle){
      const c = l.getLatLng();
      features.push({
        type:'Feature',
        properties:{name:'ADVANCE WARNING', radius_m:l.getRadius(), type:'circle'},
        geometry:{type:'Point', coordinates:[c.lng, c.lat]}
      });
    }
  });
  
  const data = {
    type:'FeatureCollection',
    properties: {
      project: document.getElementById('projectName').value || 'Untitled',
      location: document.getElementById('projectLocation').value || '',
      date: document.getElementById('projectDate').value || '',
      speed: speedEl.value
    },
    features
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/geo+json'});
  const a=document.createElement('a'); 
  a.href=URL.createObjectURL(blob); 
  a.download='work_zone.geojson'; 
  a.click();
}

function exportKML(){
  const features = [];
  if (line) features.push(line.toGeoJSON());
  coneLayer.eachLayer(m => features.push({
    type:'Feature', properties:{name:m.options.title||'Cone'},
    geometry:{type:'Point', coordinates:[m.getLatLng().lng, m.getLatLng().lat]}
  }));
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const el = l.getElement && l.getElement();
      let name = 'Sign';
      if (el && el.querySelector('.sign-pill')) name = el.innerText.trim();
      else if (el && el.querySelector('.flagger-icon')) name = 'FLAGGER';
      else if (el && el.querySelector('.arrow-board')) name = 'ARROW BOARD';
      features.push({
        type:'Feature', properties:{name},
        geometry:{type:'Point', coordinates:[l.getLatLng().lng, l.getLatLng().lat]}
      });
    }
  });
  const kml = tokml({type:'FeatureCollection', features}, {name:'name'});
  const blob = new Blob([kml], {type:'application/vnd.google-earth.kml+xml'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='work_zone.kml'; a.click();
}

function exportCSV(){
  let csv = 'Type,Name,Latitude,Longitude\n';
  
  coneLayer.eachLayer(m => {
    const ll = m.getLatLng();
    csv += `Cone,"${m.options.title||'Cone'}",${ll.lat},${ll.lng}\n`;
  });
  
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const ll = l.getLatLng();
      const el = l.getElement && l.getElement();
      let name = 'Sign';
      if (el && el.querySelector('.sign-pill')) name = el.innerText.trim();
      else if (el && el.querySelector('.flagger-icon')) name = 'FLAGGER';
      else if (el && el.querySelector('.arrow-board')) name = 'ARROW BOARD';
      csv += `Sign,"${name}",${ll.lat},${ll.lng}\n`;
    }
  });
  
  const blob = new Blob([csv], {type:'text/csv'});
  const a=document.createElement('a'); 
  a.href=URL.createObjectURL(blob); 
  a.download='work_zone.csv'; 
  a.click();
}

// Print
function updatePrintPanel(){
  document.getElementById('ppProjectName').textContent = document.getElementById('projectName').value || '—';
  document.getElementById('ppLocation').textContent = document.getElementById('projectLocation').value || '—';
  document.getElementById('ppDate').textContent = document.getElementById('projectDate').value || '—';
  document.getElementById('ppSpeed').textContent = speedEl.value;
  
  const counts = getSignCounts();
  const tbody = document.getElementById('printDevices');
  tbody.innerHTML = '';
  
  // Add cones
  const coneCount = coneLayer.getLayers().length;
  if (coneCount > 0){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>Traffic Cones</td><td><strong>${coneCount}</strong></td>`;
    tbody.appendChild(tr);
  }
  
  // Add signs
  Object.keys(counts).sort().forEach(k => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${k}</td><td><strong>${counts[k]}</strong></td>`;
    tbody.appendChild(tr);
  });
  
  if (coneCount === 0 && Object.keys(counts).length === 0){
    tbody.innerHTML = '<tr><td colspan="2">No devices placed</td></tr>';
  }
  
  document.getElementById('ppTaperSpacing').textContent = lastTaperSpacingFt ? Math.round(lastTaperSpacingFt) + ' ft' : '—';
  document.getElementById('ppTaperCones').textContent = lastTaperCones;
  document.getElementById('ppBufferSpacing').textContent = lastBufferSpacingFt ? Math.round(lastBufferSpacingFt) + ' ft' : '—';
  document.getElementById('ppBufferCones').textContent = lastBufferCones;
  document.getElementById('ppTotalCones').textContent = coneCount;
  
  // Compliance summary
  const compDiv = document.getElementById('ppCompliance');
  const speed = +speedEl.value;
  const required = calcRequiredTaperLength(speed);
  let compHTML = `<div>Required taper length (${speed} mph): <strong>${Math.round(required)} ft</strong></div>`;
  compHTML += `<div>Formula: L = WS/60 (speeds < 40 mph) or L = WS²/60 (speeds ≥ 40 mph)</div>`;
  compHTML += `<div>Where W = lane width (12 ft), S = speed limit</div>`;
  compDiv.innerHTML = compHTML;
  
  // Measurements
  const measDiv = document.getElementById('ppMeasurements');
  let totalLength = 0;
  if (line){
    totalLength = turf.length(line.toGeoJSON(), {units:'meters'})/FT_TO_M;
  }
  measDiv.innerHTML = `<div>Total project length: <strong>${fmtFt(totalLength)}</strong></div>`;
  
  // Generate QR code
  generateQRCode();
}

function generatePlan(){
  updatePrintPanel();
  // Wait for QR code canvas to render before printing
  setTimeout(() => {
    window.print();
  }, 500);
}

// Button handlers
document.getElementById('btn-place').addEventListener('click', placeCones);
document.getElementById('btn-measure').addEventListener('click', toggleMeasure);
document.getElementById('btn-clear-cones').addEventListener('click', ()=>{ coneLayer.clearLayers(); labelLayer.clearLayers(); updateStats(); });
document.getElementById('btn-clear-signs').addEventListener('click', ()=>{ signLayer.clearLayers(); updateStats(); });
document.getElementById('btn-clear-all').addEventListener('click', ()=>{ 
  coneLayer.clearLayers(); 
  labelLayer.clearLayers(); 
  signLayer.clearLayers(); 
  measureLayer.clearLayers();
  if(line){drawnItems.removeLayer(line); line=null;} 
  updateStats(); 
  updateBadges(); 
});
document.getElementById('btn-export-geojson').addEventListener('click', exportGeoJSON);
document.getElementById('btn-export-kml').addEventListener('click', exportKML);
document.getElementById('btn-export-csv').addEventListener('click', exportCSV);
document.getElementById('btn-print').addEventListener('click', generatePlan);
document.getElementById('btn-preview-qr').addEventListener('click', showQRPreview);

// Address Search
document.getElementById('btnSearch').addEventListener('click', searchAddress);
document.getElementById('addressSearch').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') searchAddress();
});

function searchAddress(){
  const query = document.getElementById('addressSearch').value.trim();
  const resultsDiv = document.getElementById('searchResults');
  
  if (!query){
    resultsDiv.innerHTML = '<span style="color:#ef4444">Please enter an address</span>';
    return;
  }
  
  resultsDiv.innerHTML = 'Searching...';
  document.getElementById('btnSearch').disabled = true;
  
  // Use Nominatim API (OpenStreetMap geocoding)
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
  
  fetch(url, {
    headers: {
      'User-Agent': 'WorkZonePlanner/1.0' // Nominatim requires a user agent
    }
  })
  .then(response => response.json())
  .then(data => {
    document.getElementById('btnSearch').disabled = false;
    
    if (data && data.length > 0){
      const result = data[0];
      const lat = parseFloat(result.lat);
      const lon = parseFloat(result.lon);
      
      // Fly to location
      map.flyTo([lat, lon], 18, {
        duration: 1.5
      });
      
      // Add temporary marker
      const tempMarker = L.marker([lat, lon], {
        icon: L.divIcon({
          className: '',
          html: '<div style="background:#3b82f6;color:#fff;padding:4px 8px;border-radius:6px;font-weight:bold;font-size:11px;border:2px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,0.5)">📍 Found</div>',
          iconSize: [0, 0]
        })
      }).addTo(map);
      
      // Auto-remove after 5 seconds
      setTimeout(() => map.removeLayer(tempMarker), 5000);
      
      resultsDiv.innerHTML = `<span style="color:var(--success)">✓ Found: ${result.display_name}</span>`;
      
      // Auto-populate project location if empty
      if (!document.getElementById('projectLocation').value){
        document.getElementById('projectLocation').value = result.display_name.split(',').slice(0, 2).join(',');
      }
    } else {
      resultsDiv.innerHTML = '<span style="color:#ef4444">Location not found. Try a different address.</span>';
    }
  })
  .catch(error => {
    console.error('Search error:', error);
    document.getElementById('btnSearch').disabled = false;
    resultsDiv.innerHTML = '<span style="color:#ef4444">Search failed. Please try again.</span>';
  });
}

// QR Preview Modal
function showQRPreview(){
  if (coneLayer.getLayers().length === 0 && signLayer.getLayers().length === 0){
    alert('Please place some cones and signs first before generating the QR code.');
    return;
  }
  
  // Check if QRious library is loaded
  if (typeof QRious === 'undefined'){
    alert('QR Code library failed to load. Please refresh the page and try again.');
    console.error('QRious library not loaded');
    return;
  }
  
  const modal = document.getElementById('qrModal');
  const qrContainer = document.getElementById('qrPreview');
  qrContainer.innerHTML = '';
  
  const data = serializeWorkZone();
  const json = JSON.stringify(data);
  const encoded = btoa(json);
  const baseUrl = window.location.href.split('#')[0].split('?')[0];
  const fieldUrl = `${baseUrl}#field=${encoded}`;
  
  console.log('Preview QR URL length:', fieldUrl.length);
  console.log('Full URL:', fieldUrl);
  
  try {
    const qr = new QRious({
      value: fieldUrl,
      size: 256, // Normal size - simpler now with compressed data
      level: 'M', // Medium error correction
      background: 'white',
      foreground: 'black'
    });
    
    qrContainer.appendChild(qr.canvas);
    qr.canvas.style.display = 'block';
    qr.canvas.style.margin = '0 auto';
    qr.canvas.style.border = '10px solid white';
    
    modal.classList.add('active');
  } catch(e){
    console.error('QR code generation error:', e);
    alert('Error generating QR code: ' + e.message);
  }
}

document.getElementById('btnCloseModal').addEventListener('click', () => {
  document.getElementById('qrModal').classList.remove('active');
});

// Close modal on outside click
document.getElementById('qrModal').addEventListener('click', (e) => {
  if (e.target.id === 'qrModal'){
    document.getElementById('qrModal').classList.remove('active');
  }
});

[spacingEl, bufferSpacingEl, scaleEl, stationStepEl].forEach(el => el.addEventListener('input', updateStats));

// ============== QR CODE & FIELD VIEW ==============

// Check if we're loading in field view mode
function checkFieldViewMode(){
  const hash = window.location.hash;
  if (hash.startsWith('#field=')){
    try {
      const data = hash.substring(7);
      const decoded = atob(data);
      const fieldData = JSON.parse(decoded);
      initFieldView(fieldData);
      return true;
    } catch(e){
      console.error('Error loading field data:', e);
    }
  }
  return false;
}

// Serialize work zone data for QR code (COMPACT VERSION)
function serializeWorkZone(){
  const devices = [];
  
  // Add cones - simplified data
  coneLayer.eachLayer(m => {
    const ll = m.getLatLng();
    devices.push({
      t: 'c', // type: cone (shortened)
      n: m.options.title || 'Cone', // name
      a: parseFloat(ll.lat.toFixed(6)), // latitude (6 decimals = ~4 inch precision)
      o: parseFloat(ll.lng.toFixed(6)), // longitude
      p: false // placed
    });
  });
  
  // Add signs - simplified data
  signLayer.eachLayer(l => {
    if (l instanceof L.Marker){
      const ll = l.getLatLng();
      const el = l.getElement && l.getElement();
      let name = 'Sign';
      if (el && el.querySelector('.sign-pill')) name = el.innerText.trim();
      else if (el && el.querySelector('.flagger-icon')) name = 'FLAGGER';
      else if (el && el.querySelector('.arrow-board')) name = 'ARROW BOARD';
      devices.push({
        t: 's', // type: sign
        n: name,
        a: parseFloat(ll.lat.toFixed(6)),
        o: parseFloat(ll.lng.toFixed(6)),
        p: false
      });
    }
  });
  
  // Get polyline coordinates if exists - simplified
  let polylineCoords = null;
  if (line){
    const gj = line.toGeoJSON();
    polylineCoords = gj.geometry.coordinates.map(c => [
      parseFloat(c[0].toFixed(6)),
      parseFloat(c[1].toFixed(6))
    ]);
  }
  
  // Compact format
  return {
    p: document.getElementById('projectName').value || 'Work Zone', // project
    s: speedEl.value, // speed
    d: devices, // devices
    l: polylineCoords // line
  };
}

// Generate QR code for field view
function generateQRCode(){
  const qrContainer = document.getElementById('qrcode');
  qrContainer.innerHTML = ''; // Clear previous
  
  if (coneLayer.getLayers().length === 0 && signLayer.getLayers().length === 0){
    qrContainer.innerHTML = '<div style="color:#666;font-size:12px">No devices to display. Place cones and signs first.</div>';
    return;
  }
  
  const data = serializeWorkZone();
  const json = JSON.stringify(data);
  const encoded = btoa(json); // Base64 encode
  
  // Create URL with encoded data
  const baseUrl = window.location.href.split('#')[0].split('?')[0];
  const fieldUrl = `${baseUrl}#field=${encoded}`;
  
  // Generate QR code
  try {
    new QRCode(qrContainer, {
      text: fieldUrl,
      width: 200,
      height: 200,
      colorDark: "#000000",
      colorLight: "#ffffff",
      correctLevel: QRCode.CorrectLevel.H // High error correction
    });
  } catch(e){
    console.error('QR code generation error:', e);
    qrContainer.innerHTML = '<div style="color:#ef4444">Error generating QR code</div>';
  }
  
  // Also display the URL for manual entry if QR fails
  const urlDisplay = document.createElement('div');
  urlDisplay.style.cssText = 'margin-top:10px;padding:8px;background:#1e293b;border-radius:6px;word-break:break-all;font-size:10px;font-family:monospace;color:#60a5fa;max-height:100px;overflow-y:auto';
  urlDisplay.textContent = fieldUrl;
  qrContainer.appendChild(urlDisplay);
}

// Initialize field view
let fieldMap = null;
let fieldDevices = [];
let currentDeviceIndex = 0;
let userMarker = null;
let gpsWatchId = null;
let guidanceLine = null;
let userHeading = 0;
let lastArrivalAlert = 0;
let activeFilter = 'all'; // Current device filter
let audioContext = null; // Audio context for sounds
let arActive = false;
let arStream = null;
let arUpdateInterval = null;
let deviceOrientation = 0;
let devicePitch = 0; // Phone tilt angle (looking up/down)
let deviceRoll = 0; // Phone rotation

// Initialize Web Audio API for sounds
function initAudio(){
  if (!audioContext){
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e){
      console.log('Web Audio API not supported');
    }
  }
}

// Play arrival beep (three ascending tones)
function playArrivalSound(){
  if (!audioContext) return;
  
  const now = audioContext.currentTime;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.type = 'sine';
  
  // Three quick beeps with ascending pitch
  oscillator.frequency.setValueAtTime(800, now);
  oscillator.frequency.setValueAtTime(1000, now + 0.15);
  oscillator.frequency.setValueAtTime(1200, now + 0.3);
  
  gainNode.gain.setValueAtTime(0.3, now);
  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
  
  oscillator.start(now);
  oscillator.stop(now + 0.5);
}

// Play success sound (happy ascending tone)
function playSuccessSound(){
  if (!audioContext) return;
  
  const now = audioContext.currentTime;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  
  oscillator.type = 'triangle';
  oscillator.frequency.setValueAtTime(600, now);
  oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.2);
  
  gainNode.gain.setValueAtTime(0.3, now);
  gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
  
  oscillator.start(now);
  oscillator.stop(now + 0.3);
}

// Play completion sound (victory fanfare)
function playCompletionSound(){
  if (!audioContext) return;
  
  const now = audioContext.currentTime;
  
  // Create three notes in a chord
  [600, 800, 1000].forEach((freq, i) => {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(freq, now);
    
    gainNode.gain.setValueAtTime(0.2, now);
    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
    
    oscillator.start(now + i * 0.1);
    oscillator.stop(now + 0.8);
  });
}

function initFieldView(data){
  document.getElementById('fieldView').classList.add('active');
  document.getElementById('app').style.display = 'none';
  
  // Set header info - handle both old and new format
  const projectName = data.p || data.project || 'Work Zone';
  const location = data.location || '';
  const dateStr = data.date || '';
  const speed = data.s || data.speed || '35';
  const devices = data.d || data.devices || [];
  
  document.getElementById('fieldProjectName').textContent = projectName;
  document.getElementById('fieldProjectInfo').innerHTML = `
    ${location ? location + ' • ' : ''}
    ${dateStr ? dateStr + ' • ' : ''}
    Speed: ${speed} mph • 
    <strong>${devices.length} devices</strong>
  `;
  
  fieldDevices = devices;
  
  // Setup filter buttons
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      // Remove active from all
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      // Add active to clicked
      btn.classList.add('active');
      // Set filter
      activeFilter = btn.getAttribute('data-filter');
      // Update visibility and navigation
      updateDeviceVisibility();
      updateFilterInfo();
      // Find first visible device
      focusNextVisibleDevice();
    });
  });
  
  // Initialize map
  setTimeout(() => {
    fieldMap = L.map('fieldViewMap', {
      minZoom: 10,
      maxZoom: 22,
      zoomControl: true
    }).setView([39.5, -98.35], 5);
    
    // Use hybrid view for field work (satellite + labels)
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri',
      maxZoom: 22
    }).addTo(fieldMap);
    
    // Add street labels overlay for field navigation
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
      attribution: '',
      maxZoom: 22
    }).addTo(fieldMap);
    
    // Draw polyline if exists - handle both formats
    const polyline = data.l || data.polyline;
    if (polyline){
      const coords = polyline.map(c => [c[1], c[0]]);
      L.polyline(coords, {
        color: '#22d3ee',
        weight: 4,
        opacity: 0.7
      }).addTo(fieldMap);
      
      // Fit bounds to polyline
      const bounds = L.latLngBounds(coords);
      fieldMap.fitBounds(bounds, {padding: [50, 50]});
    } else if (devices.length > 0){
      // Fit to devices - handle both formats
      const coords = devices.map(d => {
        const lat = d.a || d.lat;
        const lng = d.o || d.lng;
        return [lat, lng];
      });
      const bounds = L.latLngBounds(coords);
      fieldMap.fitBounds(bounds, {padding: [50, 50]});
    }
    
    // Add device markers - handle both formats
    devices.forEach((device, idx) => {
      const deviceType = device.t || device.type;
      const deviceName = device.n || device.name || 'Device';
      const lat = device.a || device.lat;
      const lng = device.o || device.lng;
      const placed = device.p !== undefined ? device.p : (device.placed || false);
      
      const isCone = deviceType === 'c' || deviceType === 'cone';
      const isTaper = deviceName.toLowerCase().includes('taper');
      const isBuffer = deviceName.toLowerCase().includes('buffer');
      
      // Determine color class
      let colorClass = '';
      if (isCone) {
        if (isTaper) colorClass = 'field-taper';
        else if (isBuffer) colorClass = 'field-buffer';
      }
      
      const icon = L.divIcon({
        className: '',
        html: `<div class="${isCone ? 'field-cone' : 'field-sign'} ${colorClass} ${placed ? 'placed' : ''}" data-num="${idx + 1}">
          ${isCone ? '🚧' : '🚸'}
        </div>`,
        iconSize: [36, 36],
        iconAnchor: [18, 18]
      });
      
      const marker = L.marker([lat, lng], {icon});
      
      marker.on('click', () => {
        showDevicePopup(marker, device, idx);
      });
      
      marker.addTo(fieldMap);
      device._marker = marker;
    });
    
    // Auto-show first device
    if (devices.length > 0){
      focusDevice(0);
    }
  }, 100);
  
  // Setup controls
  document.getElementById('btnLocateMe').addEventListener('click', startGPSTracking);
  document.getElementById('btnARMode').addEventListener('click', toggleARMode);
  document.getElementById('btnNextDevice').addEventListener('click', nextDevice);
  document.getElementById('btnExitField').addEventListener('click', () => {
    stopGPSTracking();
    if (arActive) stopARMode();
    window.location.hash = '';
    window.location.reload();
  });
  
  // AR controls
  document.getElementById('btnARClose').addEventListener('click', stopARMode);
  document.getElementById('btnARPlace').addEventListener('click', placeFromAR);
  
  // Device orientation for compass (if available)
  if (window.DeviceOrientationEvent){
    window.addEventListener('deviceorientation', handleOrientation);
  }
}

// ============== AR MODE ==============

async function toggleARMode(){
  if (arActive){
    stopARMode();
  } else {
    await startARMode();
  }
}

async function startARMode(){
  if (currentDeviceIndex < 0 || currentDeviceIndex >= fieldDevices.length){
    alert('Please select a device first using "Next Device"');
    return;
  }
  
  const device = fieldDevices[currentDeviceIndex];
  const placed = device.p !== undefined ? device.p : (device.placed || false);
  if (placed){
    alert('This device is already placed. Use "Next Device" to find the next one.');
    return;
  }
  
  // Make sure GPS is active
  if (!userMarker){
    alert('Please start GPS tracking first (📍 Start GPS button)');
    return;
  }
  
  try {
    // Request camera access
    arStream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: 'environment', // Use back camera
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      }
    });
    
    const video = document.getElementById('arCamera');
    video.srcObject = arStream;
    
    // Show AR view
    document.getElementById('arView').classList.add('active');
    arActive = true;
    
    // Update AR display continuously
    arUpdateInterval = setInterval(updateARDisplay, 100);
    
    // Request device orientation permission on iOS
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
      try {
        const permission = await DeviceOrientationEvent.requestPermission();
        if (permission !== 'granted'){
          alert('Device orientation permission needed for AR mode');
        }
      } catch (e){
        console.error('Orientation permission error:', e);
      }
    }
    
  } catch (error){
    console.error('Camera access error:', error);
    alert('Could not access camera. Make sure you granted camera permission.');
    stopARMode();
  }
}

function stopARMode(){
  if (arStream){
    arStream.getTracks().forEach(track => track.stop());
    arStream = null;
  }
  
  if (arUpdateInterval){
    clearInterval(arUpdateInterval);
    arUpdateInterval = null;
  }
  
  document.getElementById('arView').classList.remove('active');
  arActive = false;
}

function updateARDisplay(){
  if (!arActive || !userMarker) return;
  
  const userLL = userMarker.getLatLng();
  const userPt = turf.point([userLL.lng, userLL.lat]);
  
  // Clear previous device icons
  const container = document.getElementById('arDeviceContainer');
  container.innerHTML = '';
  
  // Camera parameters
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  const fovHorizontal = 60; // Horizontal field of view in degrees
  const fovVertical = 45; // Vertical field of view in degrees
  
  // Average human eye height when holding phone: ~5 feet
  const eyeHeight = 5;
  
  // Render all nearby visible devices with ground projection
  fieldDevices.forEach((device, idx) => {
    if (!isDeviceVisible(device)) return;
    
    const deviceLat = device.a || device.lat;
    const deviceLng = device.o || device.lng;
    const deviceName = device.n || device.name || 'Device';
    const deviceType = device.t || device.type;
    const placed = device.p !== undefined ? device.p : (device.placed || false);
    
    const devicePt = turf.point([deviceLng, deviceLat]);
    
    // Calculate distance
    const distM = turf.distance(userPt, devicePt, {units: 'meters'});
    const distFt = distM / FT_TO_M;
    
    // Only show devices within 150 feet
    if (distFt > 150) return;
    
    // Calculate bearing to device
    const bearing = turf.bearing(userPt, devicePt);
    
    // Calculate relative bearing (accounting for device orientation)
    let relativeBearing = bearing - deviceOrientation;
    if (relativeBearing < -180) relativeBearing += 360;
    if (relativeBearing > 180) relativeBearing -= 360;
    
    // Only show devices in camera horizontal FOV
    const halfFovH = fovHorizontal / 2;
    if (Math.abs(relativeBearing) > halfFovH) return;
    
    // Calculate horizontal screen position
    const xPercent = relativeBearing / fovHorizontal;
    const xPos = (screenWidth / 2) + (xPercent * screenWidth);
    
    // GROUND PLANE PROJECTION
    // Calculate where device appears vertically based on:
    // 1. Distance from user
    // 2. Camera pitch (tilt angle)
    // 3. Perspective projection onto ground
    
    // Pitch: 90 = phone upright (looking forward), 0 = phone flat (looking down)
    // Typical AR usage: 45-75 degrees (looking slightly down at ground)
    const pitchDeg = devicePitch;
    
    // Calculate angle from camera to ground object
    // Using simplified perspective: tan(angle) = height / distance
    const angleToGround = Math.atan(eyeHeight / distFt) * (180 / Math.PI);
    
    // Where object appears relative to camera center
    // If camera points down (low pitch), nearby objects appear lower on screen
    // If camera points forward (high pitch), objects appear higher (toward horizon)
    const cameraLookAngle = 90 - pitchDeg; // How far down from horizontal camera is tilted
    const objectAngleFromCenter = cameraLookAngle - angleToGround;
    
    // Convert to screen position
    // Vertical FOV determines how many degrees fit on screen
    const yPercent = objectAngleFromCenter / fovVertical;
    const yPos = (screenHeight / 2) - (yPercent * screenHeight);
    
    // Don't show if off-screen vertically
    if (yPos < -50 || yPos > screenHeight + 50) return;
    
    // Scale based on distance (closer = bigger)
    // Use perspective scaling: apparent size = actual size / distance
    const baseSize = 40; // Base icon size in pixels
    const scaleFactor = 150 / Math.max(distFt, 10); // Scale factor based on reference distance
    const scale = Math.min(scaleFactor, 3); // Cap maximum scale
    
    // Create device icon
    const deviceDiv = document.createElement('div');
    deviceDiv.className = 'ar-device';
    if (idx === currentDeviceIndex) deviceDiv.classList.add('current');
    if (placed) deviceDiv.classList.add('placed');
    
    const isCone = deviceType === 'c' || deviceType === 'cone';
    const isTaper = deviceName.toLowerCase().includes('taper');
    const isBuffer = deviceName.toLowerCase().includes('buffer');
    
    if (isTaper) deviceDiv.classList.add('taper');
    if (isBuffer) deviceDiv.classList.add('buffer');
    
    deviceDiv.style.left = `${xPos}px`;
    deviceDiv.style.top = `${yPos}px`;
    deviceDiv.style.transform = `translate(-50%, -100%) scale(${scale})`; // -100% to anchor at bottom
    
    // Show distance only if not too close
    const showDist = distFt >= 5;
    
    if (isCone){
      deviceDiv.innerHTML = `
        <div class="ar-cone-3d">
          <div class="cone-shadow"></div>
          <div class="cone-base-3d"></div>
          <div class="cone-body"></div>
          <div class="cone-stripe"></div>
          ${showDist ? `<div class="ar-device-label">${Math.round(distFt)}ft</div>` : ''}
        </div>
      `;
    } else {
      deviceDiv.innerHTML = `
        <div class="ar-sign-3d">
          <div class="sign-shadow"></div>
          <div class="sign-post"></div>
          <div class="sign-panel">🚸</div>
          ${showDist ? `<div class="ar-device-label">${Math.round(distFt)}ft</div>` : ''}
        </div>
      `;
    }
    
    container.appendChild(deviceDiv);
  });
  
  // Update current target info (existing code)
  const device = fieldDevices[currentDeviceIndex];
  if (!device) return;
  
  const deviceLat = device.a || device.lat;
  const deviceLng = device.o || device.lng;
  
  const devicePt = turf.point([deviceLng, deviceLat]);
  
  // Calculate distance to current target
  const distM = turf.distance(userPt, devicePt, {units: 'meters'});
  const distFt = Math.round(distM / FT_TO_M);
  
  // Calculate bearing to target
  const bearing = turf.bearing(userPt, devicePt);
  
  // Update distance display
  document.getElementById('arDistance').textContent = `${distFt} ft`;
  
  // Calculate relative bearing
  let relativeBearing = bearing - deviceOrientation;
  if (relativeBearing < -180) relativeBearing += 360;
  if (relativeBearing > 180) relativeBearing -= 360;
  
  // Update arrow rotation
  const arrow = document.getElementById('arArrow');
  arrow.style.transform = `rotate(${relativeBearing}deg)`;
  
  // Update direction text
  const dirText = getARDirectionText(relativeBearing, distFt);
  document.getElementById('arDirection').textContent = dirText;
  
  // Check for snap-to-location (within 3 feet)
  const snapIndicator = document.getElementById('arSnap');
  if (distFt <= 3){
    snapIndicator.style.display = 'block';
    if (navigator.vibrate && distFt <= 2){
      navigator.vibrate(50);
    }
  } else {
    snapIndicator.style.display = 'none';
  }
  
  // Change arrow opacity based on distance
  if (distFt <= 10){
    arrow.style.opacity = '1';
  } else if (distFt <= 30){
    arrow.style.opacity = '0.8';
  } else {
    arrow.style.opacity = '0.6';
  }
}

function getARDirectionText(bearing, distFt){
  const absBearing = Math.abs(bearing);
  
  if (distFt <= 3){
    return '✓ Perfect position!';
  } else if (distFt <= 10){
    if (absBearing < 15){
      return 'Straight ahead';
    } else if (bearing > 0){
      return `Turn right ${Math.round(absBearing)}°`;
    } else {
      return `Turn left ${Math.round(absBearing)}°`;
    }
  } else {
    if (absBearing < 20){
      return `Go straight ${distFt} ft`;
    } else if (bearing > 0){
      return `Turn right and go ${distFt} ft`;
    } else {
      return `Turn left and go ${distFt} ft`;
    }
  }
}

function placeFromAR(){
  if (!userMarker) {
    alert('GPS not active. Start GPS tracking first.');
    return;
  }
  
  const device = fieldDevices[currentDeviceIndex];
  if (!device) return;
  
  const deviceLat = device.a || device.lat;
  const deviceLng = device.o || device.lng;
  
  const userLL = userMarker.getLatLng();
  const userPt = turf.point([userLL.lng, userLL.lat]);
  const devicePt = turf.point([deviceLng, deviceLat]);
  
  const distM = turf.distance(userPt, devicePt, {units: 'meters'});
  const distFt = Math.round(distM / FT_TO_M);
  
  if (distFt > 10){
    if (!confirm(`You're ${distFt} ft away from target. Place here anyway?`)){
      return;
    }
  }
  
  // Mark as placed
  markDevicePlaced(currentDeviceIndex);
  
  // Exit AR mode
  stopARMode();
}

// Device filtering functions
function getDeviceCategory(device){
  const deviceName = device.n || device.name || '';
  const deviceType = device.t || device.type;
  
  if (deviceType === 's' || deviceType === 'sign') return 'sign';
  
  const nameLower = deviceName.toLowerCase();
  if (nameLower.includes('taper')) return 'taper';
  if (nameLower.includes('buffer')) return 'buffer';
  
  return 'cone'; // default for uncategorized cones
}

function isDeviceVisible(device){
  if (activeFilter === 'all') return true;
  return getDeviceCategory(device) === activeFilter;
}

function updateDeviceVisibility(){
  fieldDevices.forEach(device => {
    if (device._marker){
      const visible = isDeviceVisible(device);
      const el = device._marker.getElement();
      if (el){
        el.style.display = visible ? 'block' : 'none';
      }
    }
  });
}

function updateFilterInfo(){
  const visible = fieldDevices.filter(d => {
    const placed = d.p !== undefined ? d.p : (d.placed || false);
    return isDeviceVisible(d) && !placed;
  }).length;
  
  const filterName = activeFilter === 'all' ? 'All Devices' : 
                     activeFilter === 'taper' ? 'Taper Cones' :
                     activeFilter === 'buffer' ? 'Buffer Cones' : 'Signs';
  
  document.getElementById('fieldProjectInfo').innerHTML = 
    document.getElementById('fieldProjectInfo').innerHTML.split('<strong>')[0] + 
    `<strong>${visible} ${filterName}</strong>`;
}

function focusNextVisibleDevice(){
  // Find first unplaced visible device
  for (let i = 0; i < fieldDevices.length; i++){
    const device = fieldDevices[i];
    const placed = device.p !== undefined ? device.p : (device.placed || false);
    if (!placed && isDeviceVisible(device)){
      focusDevice(i);
      return;
    }
  }
  // All visible devices placed
  updateNextButton();
}

function showDevicePopup(marker, device, idx){
  // Handle both old and new format
  const deviceType = device.t || device.type;
  const deviceName = device.n || device.name || 'Device';
  const lat = device.a || device.lat;
  const lng = device.o || device.lng;
  
  const distanceText = userMarker ? 
    `<div style="margin:8px 0;padding:8px;background:rgba(34,197,94,0.1);border-radius:6px;border:1px solid #22c55e">
      <div style="color:var(--success);font-weight:bold">📍 Distance: ${getDistanceToUser(device)} ft</div>
    </div>` : '';
  
  const isCone = deviceType === 'c' || deviceType === 'cone';
  const popup = `
    <div class="device-popup">
      <strong>${isCone ? '🚧 Cone' : '🚸 Sign'}: ${deviceName}</strong>
      <div class="coord">Lat: ${lat.toFixed(6)}<br>Lng: ${lng.toFixed(6)}</div>
      ${distanceText}
      <button onclick="markDevicePlaced(${idx})" style="margin-top:8px;width:100%;padding:8px;background:var(--success);border:none;border-radius:6px;font-weight:bold;cursor:pointer;font-size:13px">
        ✓ Mark as Placed
      </button>
    </div>
  `;
  
  marker.bindPopup(popup, {className: 'dark-popup'}).openPopup();
}

function focusDevice(idx){
  if (idx < 0 || idx >= fieldDevices.length) return;
  
  currentDeviceIndex = idx;
  const device = fieldDevices[idx];
  
  if (device._marker){
    fieldMap.setView([device.lat, device.lng], 20, {animate: true});
    showDevicePopup(device._marker, device, idx);
    
    // If GPS is active, navigation will auto-update
    if (gpsWatchId !== null && userMarker){
      const userLL = userMarker.getLatLng();
      updateNavigation(userLL.lat, userLL.lng, 10);
    }
  }
  
  updateNextButton();
}

function nextDevice(){
  // Find next unplaced visible device - handle both formats
  let nextIdx = currentDeviceIndex + 1;
  for (let i = 0; i < fieldDevices.length; i++){
    const idx = (nextIdx + i) % fieldDevices.length;
    const device = fieldDevices[idx];
    const placed = device.p !== undefined ? device.p : (device.placed || false);
    
    // Check if device is visible based on current filter
    if (!placed && isDeviceVisible(device)){
      focusDevice(idx);
      
      // If GPS tracking is active, force navigation update
      if (gpsWatchId !== null && userMarker){
        const userLL = userMarker.getLatLng();
        updateNavigation(userLL.lat, userLL.lng, 10);
      }
      return;
    }
  }
  
  // All visible devices placed
  const totalRemaining = fieldDevices.filter(d => {
    const placed = d.p !== undefined ? d.p : (d.placed || false);
    return !placed;
  }).length;
  
  if (totalRemaining > 0){
    // Some devices left but in other categories
    const filterName = activeFilter === 'taper' ? 'taper cones' :
                       activeFilter === 'buffer' ? 'buffer cones' : 
                       activeFilter === 'sign' ? 'signs' : 'devices';
    alert(`✓ All ${filterName} placed! Switch filter to place remaining devices.`);
  } else {
    // Everything done
    stopGPSTracking();
    alert('✓ All devices have been placed! Great work!');
  }
}

function updateNextButton(){
  const remaining = fieldDevices.filter(d => {
    const placed = d.p !== undefined ? d.p : (d.placed || false);
    return !placed && isDeviceVisible(d);
  }).length;
  const btn = document.getElementById('btnNextDevice');
  btn.innerHTML = remaining > 0 ? `→ Next (${remaining} left)` : '✓ All Placed';
}

// GPS Tracking and Navigation
function startGPSTracking(){
  if (!navigator.geolocation){
    alert('Geolocation is not supported by your device');
    return;
  }
  
  const btn = document.getElementById('btnLocateMe');
  
  if (gpsWatchId !== null){
    // Stop tracking
    stopGPSTracking();
    return;
  }
  
  // Initialize audio on user interaction
  initAudio();
  
  btn.style.background = 'var(--success)';
  btn.textContent = '📍 GPS Active';
  
  // Show navigation UI
  document.getElementById('navPanel').classList.remove('hidden');
  document.getElementById('compassContainer').style.display = 'block';
  
  // Start continuous tracking
  gpsWatchId = navigator.geolocation.watchPosition(
    updateUserPosition,
    handleGPSError,
    {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 5000
    }
  );
}

function stopGPSTracking(){
  if (gpsWatchId !== null){
    navigator.geolocation.clearWatch(gpsWatchId);
    gpsWatchId = null;
  }
  
  const btn = document.getElementById('btnLocateMe');
  btn.style.background = '';
  btn.textContent = '📍 Start GPS';
  
  document.getElementById('navPanel').classList.add('hidden');
  document.getElementById('compassContainer').style.display = 'none';
  
  if (guidanceLine){
    fieldMap.removeLayer(guidanceLine);
    guidanceLine = null;
  }
}

function updateUserPosition(position){
  const lat = position.coords.latitude;
  const lng = position.coords.longitude;
  const accuracy = position.coords.accuracy;
  
  // Update or create user marker
  if (userMarker){
    userMarker.setLatLng([lat, lng]);
    if (userMarker._circle) userMarker._circle.setLatLng([lat, lng]).setRadius(accuracy);
  } else {
    // Accuracy circle
    const circle = L.circle([lat, lng], {
      radius: accuracy,
      color: '#3b82f6',
      fillColor: '#3b82f6',
      fillOpacity: 0.15,
      weight: 1
    }).addTo(fieldMap);
    
    // User position marker
    userMarker = L.circleMarker([lat, lng], {
      radius: 10,
      color: '#fff',
      fillColor: '#3b82f6',
      fillOpacity: 1,
      weight: 3
    }).addTo(fieldMap);
    
    userMarker._circle = circle;
    userMarker.bindPopup('📍 Your Location');
    
    // Center on user first time
    fieldMap.setView([lat, lng], 19, {animate: true});
  }
  
  // Update navigation to current device
  if (currentDeviceIndex >= 0 && currentDeviceIndex < fieldDevices.length){
    updateNavigation(lat, lng, accuracy);
  }
  
  // Update compass accuracy display
  document.getElementById('compassAccuracy').textContent = 
    accuracy < 10 ? 'High accuracy' : 
    accuracy < 30 ? 'Good accuracy' : 
    'Low accuracy';
}

function updateNavigation(userLat, userLng, accuracy){
  const device = fieldDevices[currentDeviceIndex];
  if (!device) return;
  
  // Handle both formats
  const placed = device.p !== undefined ? device.p : (device.placed || false);
  if (placed) return;
  
  const deviceLat = device.a || device.lat;
  const deviceLng = device.o || device.lng;
  const deviceName = device.n || device.name || 'Device';
  
  const userPt = turf.point([userLng, userLat]);
  const devicePt = turf.point([deviceLng, deviceLat]);
  
  // Calculate distance
  const distM = turf.distance(userPt, devicePt, {units: 'meters'});
  const distFt = Math.round(distM / FT_TO_M);
  
  // Calculate bearing
  const bearing = turf.bearing(userPt, devicePt);
  
  // Update navigation panel
  updateNavigationPanel(distFt, bearing, deviceName);
  
  // Update compass arrow
  updateCompass(bearing);
  
  // Draw guidance line
  drawGuidanceLine([userLat, userLng], [deviceLat, deviceLng]);
  
  // Check if arrived (within 10 feet)
  if (distFt <= 10 && Date.now() - lastArrivalAlert > 5000){
    showArrivalNotification(deviceName);
    playArrivalSound(); // Play audio notification
    lastArrivalAlert = Date.now();
    
    // Auto-open popup
    if (device._marker){
      showDevicePopup(device._marker, device, currentDeviceIndex);
    }
  }
}

function updateNavigationPanel(distFt, bearing, deviceName){
  // Distance
  const distEl = document.getElementById('navDistance');
  if (distFt < 100){
    distEl.textContent = `${distFt} ft`;
  } else {
    distEl.textContent = `${Math.round(distFt / 5) * 5} ft`;
  }
  
  // Direction
  const dirText = getDirectionText(bearing, distFt);
  document.getElementById('navDirectionText').textContent = dirText.text;
  document.getElementById('navArrowText').textContent = dirText.arrow;
  
  // Device name
  document.getElementById('navDeviceName').textContent = deviceName;
}

function getDirectionText(bearing, distFt){
  // Adjust bearing for device heading if available
  let relativeBearing = bearing - userHeading;
  if (relativeBearing < 0) relativeBearing += 360;
  if (relativeBearing > 360) relativeBearing -= 360;
  
  // Cardinal directions
  let cardinalDir = '';
  if (relativeBearing >= 337.5 || relativeBearing < 22.5) cardinalDir = 'ahead';
  else if (relativeBearing >= 22.5 && relativeBearing < 67.5) cardinalDir = 'ahead and right';
  else if (relativeBearing >= 67.5 && relativeBearing < 112.5) cardinalDir = 'to your right';
  else if (relativeBearing >= 112.5 && relativeBearing < 157.5) cardinalDir = 'behind and right';
  else if (relativeBearing >= 157.5 && relativeBearing < 202.5) cardinalDir = 'behind you';
  else if (relativeBearing >= 202.5 && relativeBearing < 247.5) cardinalDir = 'behind and left';
  else if (relativeBearing >= 247.5 && relativeBearing < 292.5) cardinalDir = 'to your left';
  else cardinalDir = 'ahead and left';
  
  // Arrow emoji
  let arrow = '⬆️';
  if (relativeBearing >= 22.5 && relativeBearing < 67.5) arrow = '↗️';
  else if (relativeBearing >= 67.5 && relativeBearing < 112.5) arrow = '➡️';
  else if (relativeBearing >= 112.5 && relativeBearing < 157.5) arrow = '↘️';
  else if (relativeBearing >= 157.5 && relativeBearing < 202.5) arrow = '⬇️';
  else if (relativeBearing >= 202.5 && relativeBearing < 247.5) arrow = '↙️';
  else if (relativeBearing >= 247.5 && relativeBearing < 292.5) arrow = '⬅️';
  else if (relativeBearing >= 292.5 && relativeBearing < 337.5) arrow = '↖️';
  
  // Distance-based text
  let text = '';
  if (distFt <= 10) text = 'You have arrived';
  else if (distFt <= 30) text = `${cardinalDir}, ${distFt} feet`;
  else if (distFt <= 100) text = `Continue ${cardinalDir}`;
  else text = `Head ${cardinalDir}`;
  
  return {text, arrow};
}

function updateCompass(bearing){
  const arrow = document.getElementById('compassArrow');
  // Rotate arrow to point at target (accounting for device orientation)
  const rotation = bearing - userHeading;
  arrow.style.transform = `rotate(${rotation}deg)`;
}

function drawGuidanceLine(userCoords, deviceCoords){
  if (guidanceLine){
    fieldMap.removeLayer(guidanceLine);
  }
  
  guidanceLine = L.polyline([userCoords, deviceCoords], {
    color: '#22c55e',
    weight: 3,
    dashArray: '8,8',
    opacity: 0.8,
    className: 'guidance-line'
  }).addTo(fieldMap);
}

function showArrivalNotification(deviceName){
  const banner = document.createElement('div');
  banner.className = 'arrival-banner';
  banner.textContent = `✓ Arrived: ${deviceName}`;
  document.getElementById('fieldViewMap').appendChild(banner);
  
  // Vibrate if supported
  if (navigator.vibrate){
    navigator.vibrate([200, 100, 200]);
  }
  
  setTimeout(() => banner.remove(), 3000);
}

function handleGPSError(error){
  console.error('GPS error:', error);
  const btn = document.getElementById('btnLocateMe');
  btn.style.background = 'var(--danger)';
  btn.textContent = '⚠️ GPS Error';
  
  setTimeout(() => {
    btn.style.background = '';
    btn.textContent = '📍 Start GPS';
  }, 3000);
}

function handleOrientation(event){
  if (event.alpha !== null){
    userHeading = event.alpha; // Device compass heading
    deviceOrientation = event.alpha; // Store for AR mode too
  }
  
  // Beta = pitch (tilting phone forward/back) -180 to 180
  // 0 = flat, 90 = standing upright, -90 = upside down
  if (event.beta !== null){
    devicePitch = event.beta;
  }
  
  // Gamma = roll (tilting phone left/right) -90 to 90
  if (event.gamma !== null){
    deviceRoll = event.gamma;
  }
  
  // Also use webkitCompassHeading on iOS if available
  if (event.webkitCompassHeading !== undefined){
    userHeading = event.webkitCompassHeading;
    deviceOrientation = event.webkitCompassHeading;
  }
}

function locateUser(){
  // Fallback single location (for testing or if watch fails)
  if (!navigator.geolocation){
    alert('Geolocation is not supported by your device');
    return;
  }
  
  document.getElementById('btnLocateMe').textContent = '📍 Locating...';
  
  navigator.geolocation.getCurrentPosition(
    (position) => {
      updateUserPosition(position);
    },
    (error) => {
      alert('Could not get your location: ' + error.message);
      document.getElementById('btnLocateMe').textContent = '📍 My Location';
    },
    {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    }
  );
}

function getDistanceToUser(device){
  if (!userMarker) return '—';
  
  const userLL = userMarker.getLatLng();
  
  // Handle both formats
  const deviceLat = device.a || device.lat;
  const deviceLng = device.o || device.lng;
  
  const devicePt = turf.point([deviceLng, deviceLat]);
  const userPt = turf.point([userLL.lng, userLL.lat]);
  const distM = turf.distance(devicePt, userPt, {units: 'meters'});
  const distFt = Math.round(distM / FT_TO_M);
  
  return distFt.toLocaleString();
}

// Make this global so popup button can call it
window.markDevicePlaced = function(idx){
  if (idx >= 0 && idx < fieldDevices.length){
    // Update in both old and new format
    fieldDevices[idx].p = true;
    fieldDevices[idx].placed = true;
    
    // Update marker appearance
    if (fieldDevices[idx]._marker){
      const el = fieldDevices[idx]._marker.getElement();
      if (el){
        const markerDiv = el.querySelector('.placement-marker');
        if (markerDiv) markerDiv.classList.add('placed');
      }
      fieldDevices[idx]._marker.closePopup();
    }
    
    updateNextButton();
    updateFilterInfo();
    
    // Play success sound/vibration
    playSuccessSound();
    if (navigator.vibrate){
      navigator.vibrate(200);
    }
    
    // Auto-advance to next after short delay
    setTimeout(() => {
      const visibleRemaining = fieldDevices.filter(d => {
        const placed = d.p !== undefined ? d.p : (d.placed || false);
        return !placed && isDeviceVisible(d);
      }).length;
      
      const totalRemaining = fieldDevices.filter(d => {
        const placed = d.p !== undefined ? d.p : (d.placed || false);
        return !placed;
      }).length;
      
      if (visibleRemaining > 0){
        nextDevice();
      } else if (totalRemaining > 0){
        // Current filter category done, but others remain
        const filterName = activeFilter === 'taper' ? 'taper cones' :
                           activeFilter === 'buffer' ? 'buffer cones' : 
                           activeFilter === 'sign' ? 'signs' : 'devices in this category';
        const banner = document.createElement('div');
        banner.className = 'arrival-banner';
        banner.innerHTML = `✓ All ${filterName} placed!<br><span style="font-size:14px">Switch filter for more</span>`;
        document.getElementById('fieldViewMap').appendChild(banner);
        
        playSuccessSound();
        if (navigator.vibrate){
          navigator.vibrate([200, 100, 200]);
        }
        
        setTimeout(() => banner.remove(), 3000);
      } else {
        // All done!
        stopGPSTracking();
        const banner = document.createElement('div');
        banner.className = 'arrival-banner';
        banner.innerHTML = '🎉 Work Zone Complete!<br><span style="font-size:14px">All devices placed</span>';
        document.getElementById('fieldViewMap').appendChild(banner);
        
        playCompletionSound();
        if (navigator.vibrate){
          navigator.vibrate([200, 100, 200, 100, 200]);
        }
        
        setTimeout(() => banner.remove(), 5000);
      }
    }, 800);
  }
};

// Check for field view mode on load
if (!checkFieldViewMode()){
  // Normal editor mode - initialize as before
  updateStats();
  updateBadges();
}
</script>
</body>
</html>
